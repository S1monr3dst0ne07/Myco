/**
 * @file eval.c
 * @brief Myco Language Evaluator - Executes Abstract Syntax Tree (AST)
 * @version 1.0.0
 * @author Myco Development Team
 * 
 * This file implements the evaluation phase of the Myco interpreter.
 * It takes the parsed AST and executes the program, handling all runtime
 * operations including variable management, function calls, and control flow.
 * 
 * Evaluator Features:
 * - AST execution with scope management
 * - Variable environment with reassignment support
 * - Function call handling with parameter binding
 * - Module system with import/export
 * - Error handling and reporting
 * - Memory management and cleanup
 * - Loop execution with safety limits
 * 
 * Core Components:
 * - Variable environment (local and global scope)
 * - Function registry and lookup
 * - Module registry and management
 * - Error state management
 * - Loop execution state management
 * 
 * Architecture:
 * - Recursive AST traversal
 * - Dynamic scope management
 * - Memory-efficient variable storage
 * - Cross-platform compatibility
 */

#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "parser.h"
#include "memory_tracker.h"
#include <sys/stat.h>
#include <dirent.h>
#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/select.h>
#endif
#include "eval.h"
#include "lexer.h"
#include "config.h"
#include "loop_manager.h"
#include <errno.h>
#include <time.h>
#include <math.h>
#include <float.h>
#include <limits.h>

// Array data structure is now defined in eval.h

/*******************************************************************************
 * SIMPLE LIBRARY IMPORT SYSTEM
 ******************************************************************************/

// Forward declarations for library functions
static long long call_math_function(const char* func_name, ASTNode* args_node);
static long long call_util_function(const char* func_name, ASTNode* args_node);
static long long call_core_function(const char* func_name, ASTNode* args_node);
static long long call_file_io_function(const char* func_name, ASTNode* args_node);
static long long call_array_function(const char* func_name, ASTNode* args_node);
static long long call_object_function(const char* func_name, ASTNode* args_node);
static long long call_path_utils_function(const char* func_name, ASTNode* args_node);
static long long call_env_function(const char* func_name, ASTNode* args_node);
static long long call_args_function(const char* func_name, ASTNode* args_node);
static long long call_process_function(const char* func_name, ASTNode* args_node);
static long long call_text_utils_function(const char* func_name, ASTNode* args_node);
static long long call_debug_function(const char* func_name, ASTNode* args_node);

// Global library imports
static LibraryImport* library_imports = NULL;
static int library_import_count = 0;
static int library_import_capacity = 0;

// Global command-line arguments storage
static char** global_argv = NULL;
static int global_argc = 0;

// Global error handling and debugging state
static int debug_mode = 0;
static int warning_count = 0;
static int error_count = 0;
static char last_error_message[2048] = "";
static char last_warning_message[2048] = "";
static int performance_timer_active = 0;
static clock_t performance_start_time = 0;

/**
 * @brief Add a library import
 */
void add_library_import(const char* library_name, const char* alias) {
    if (library_import_count >= library_import_capacity) {
        library_import_capacity = library_import_capacity == 0 ? 10 : library_import_capacity * 2;
        library_imports = (LibraryImport*)tracked_realloc(
            library_imports, 
            library_import_capacity * sizeof(LibraryImport), 
            __FILE__, __LINE__, "add_library_import"
        );
    }
    
    library_imports[library_import_count].library_name = tracked_strdup(library_name, __FILE__, __LINE__, "add_library_import");
    library_imports[library_import_count].alias = tracked_strdup(alias, __FILE__, __LINE__, "add_library_import");
    library_import_count++;
    
    printf("Imported library '%s' as '%s'\n", library_name, alias);
}

/**
 * @brief Get library name for an alias
 */
const char* get_library_alias(const char* alias) {
    for (int i = 0; i < library_import_count; i++) {
        if (strcmp(library_imports[i].alias, alias) == 0) {
            return library_imports[i].library_name;
        }
    }
    return NULL;
}

/**
 * @brief Initialize the library system
 */
void init_libraries(void) {
    // Initialize library import system
    library_imports = NULL;
    library_import_count = 0;
    library_import_capacity = 0;
    

}

/**
 * @brief Set command-line arguments for the args library
 */
void set_command_line_args(int argc, char** argv) {
    global_argc = argc;
    global_argv = argv;
}

/**
 * @brief Cleanup the library system
 */
void cleanup_libraries(void) {
    if (library_imports) {
        for (int i = 0; i < library_import_count; i++) {
            if (library_imports[i].library_name) {
                tracked_free(library_imports[i].library_name, __FILE__, __LINE__, "cleanup_libraries");
            }
            if (library_imports[i].alias) {
                tracked_free(library_imports[i].alias, __FILE__, __LINE__, "cleanup_libraries");
            }
        }
        tracked_free(library_imports, __FILE__, __LINE__, "cleanup_libraries");
        library_imports = NULL;
        library_import_count = 0;
        library_import_capacity = 0;
    }
    

}

/*******************************************************************************
 * IMPLICIT FUNCTION SYSTEM
 ******************************************************************************/

// Forward declaration for eval_expression
long long eval_expression(ASTNode* ast);

/**
 * @brief Global operator mapping table for implicit functions
 * 
 * This table maps operators to their corresponding function names
 * and defines precedence, associativity, and supported type combinations.
 */
static OperatorMapping* operator_map = NULL;
static int operator_map_size = 0;
static int operator_map_capacity = 0;

/**
 * @brief Initialize the implicit function system
 * 
 * Sets up the operator mapping table with all supported operators
 * and their corresponding function names.
 */
void init_implicit_functions(void) {
    if (operator_map) return; // Already initialized
    
    operator_map_capacity = 20;
    operator_map = (OperatorMapping*)tracked_malloc(
        operator_map_capacity * sizeof(OperatorMapping), 
        __FILE__, __LINE__, "init_implicit_functions"
    );
    
    if (!operator_map) {
        fprintf(stderr, "Error: Failed to initialize implicit functions\n");
        return;
    }
    
    // Mathematical operators
    operator_map[operator_map_size].operator = "+";
    operator_map[operator_map_size].function_name = "add";
    operator_map[operator_map_size].precedence = 4;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 1;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "-";
    operator_map[operator_map_size].function_name = "subtract";
    operator_map[operator_map_size].precedence = 4;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "*";
    operator_map[operator_map_size].function_name = "multiply";
    operator_map[operator_map_size].precedence = 5;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1; // For string repetition
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 1; // For array repetition
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "/";
    operator_map[operator_map_size].function_name = "divide";
    operator_map[operator_map_size].precedence = 5;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "%";
    operator_map[operator_map_size].function_name = "modulo";
    operator_map[operator_map_size].precedence = 5;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    // Comparison operators
    operator_map[operator_map_size].operator = "==";
    operator_map[operator_map_size].function_name = "equals";
    operator_map[operator_map_size].precedence = 2;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 1;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "!=";
    operator_map[operator_map_size].function_name = "not_equals";
    operator_map[operator_map_size].precedence = 2;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 1;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "<";
    operator_map[operator_map_size].function_name = "less_than";
    operator_map[operator_map_size].precedence = 3;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = ">";
    operator_map[operator_map_size].function_name = "greater_than";
    operator_map[operator_map_size].precedence = 3;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "<=";
    operator_map[operator_map_size].function_name = "less_equal";
    operator_map[operator_map_size].precedence = 3;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = ">=";
    operator_map[operator_map_size].function_name = "greater_equal";
    operator_map[operator_map_size].precedence = 3;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    // Logical operators
    operator_map[operator_map_size].operator = "and";
    operator_map[operator_map_size].function_name = "logical_and";
    operator_map[operator_map_size].precedence = 1;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    operator_map[operator_map_size].operator = "or";
    operator_map[operator_map_size].function_name = "logical_or";
    operator_map[operator_map_size].precedence = 1;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 0;
    operator_map_size++;
    
    // Special operators
    operator_map[operator_map_size].operator = "in";
    operator_map[operator_map_size].function_name = "contains";
    operator_map[operator_map_size].precedence = 3;
    operator_map[operator_map_size].associativity = LEFT_ASSOC;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_NUMERIC] = 0;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_STRING] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_ARRAY] = 1;
    operator_map[operator_map_size].supports_types[TYPE_COMBINATION_OBJECT] = 1;
    operator_map_size++;
    

}

/**
 * @brief Get the appropriate implicit function for an operator and type combination
 * @param operator The operator symbol
 * @param left_type The type of the left operand
 * @param right_type The type of the right operand
 * @return Function name to call, or NULL if no suitable function found
 */
char* get_implicit_function(const char* operator, int left_type, int right_type) {
    if (!operator_map) return NULL;
    
    int type_combo = get_type_combination(left_type, right_type);
    
    for (int i = 0; i < operator_map_size; i++) {
        if (strcmp(operator_map[i].operator, operator) == 0) {
            if (operator_map[i].supports_types[type_combo]) {
                return operator_map[i].function_name;
            }
        }
    }
    
    return NULL;
}

/**
 * @brief Determine the type combination for two operands
 * @param left_type The type of the left operand
 * @param right_type The type of the right operand
 * @return Type combination constant
 */
int get_type_combination(int left_type, int right_type) {
    // For now, we'll use a simple mapping
    // In the future, this could be more sophisticated
    if (left_type == 0 && right_type == 0) {  // VAR_TYPE_NUMBER = 0
        return TYPE_COMBINATION_NUMERIC;
    } else if (left_type == 1 && right_type == 1) {  // VAR_TYPE_STRING = 1
        return TYPE_COMBINATION_STRING;
    } else if (left_type == 2 && right_type == 2) {  // VAR_TYPE_ARRAY = 2
        return TYPE_COMBINATION_ARRAY;
    } else if (left_type == 3 && right_type == 3) {  // VAR_TYPE_OBJECT = 3
        return TYPE_COMBINATION_OBJECT;
    }
    
    // Default to numeric for mixed types (will be handled by type coercion)
    return TYPE_COMBINATION_NUMERIC;
}

/**
 * @brief Call an implicit function with the given arguments
 * @param function_name The name of the function to call
 * @param children The AST node containing the arguments
 * @param child_count The number of arguments
 * @return The result of the function call
 */
long long call_implicit_function(const char* function_name, ASTNode* children, int child_count) {
    if (!function_name || !children || child_count < 2) return 0;
    
    // Evaluate the left and right operands
    long long left_value = eval_expression(&children[0]);
    long long right_value = eval_expression(&children[1]);
    
    // For now, we'll implement basic numeric operations
    // In the future, this will call the actual built-in functions
    
    if (strcmp(function_name, "add") == 0) {
        return left_value + right_value;
    } else if (strcmp(function_name, "subtract") == 0) {
        return left_value - right_value;
    } else if (strcmp(function_name, "multiply") == 0) {
        return left_value * right_value;
    } else if (strcmp(function_name, "divide") == 0) {
        if (right_value == 0) {
            fprintf(stderr, "Error: Division by zero\n");
            return 0;
        }
        return left_value / right_value;
    } else if (strcmp(function_name, "modulo") == 0) {
        if (right_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            return 0;
        }
        return left_value % right_value;
    } else if (strcmp(function_name, "equals") == 0) {
        return left_value == right_value ? 1 : 0;
    } else if (strcmp(function_name, "not_equals") == 0) {
        return left_value != right_value ? 1 : 0;
    } else if (strcmp(function_name, "less_than") == 0) {
        return left_value < right_value ? 1 : 0;
    } else if (strcmp(function_name, "greater_than") == 0) {
        return left_value > right_value ? 1 : 0;
    } else if (strcmp(function_name, "less_equal") == 0) {
        return left_value <= right_value ? 1 : 0;
    } else if (strcmp(function_name, "greater_equal") == 0) {
        return left_value >= right_value ? 1 : 0;
    } else if (strcmp(function_name, "logical_and") == 0) {
        return (left_value != 0 && right_value != 0) ? 1 : 0;
    } else if (strcmp(function_name, "logical_or") == 0) {
        return (left_value != 0 || right_value != 0) ? 1 : 0;
    }
    
    fprintf(stderr, "Error: Unknown implicit function '%s'\n", function_name);
    return 0;
}

/**
 * @brief Clean up the implicit function system
 */
void cleanup_implicit_functions(void) {
    if (operator_map) {
        tracked_free(operator_map, __FILE__, __LINE__, "cleanup_implicit_functions");
        operator_map = NULL;
        operator_map_size = 0;
        operator_map_capacity = 0;
    }
}

/*******************************************************************************
 * MATH LIBRARY v1.3.0
 ******************************************************************************/

// Mathematical constants
#define MYCO_PI 3.14159265358979323846
#define MYCO_E 2.71828182845904523536
#define MYCO_INF (1.0/0.0)
#define MYCO_NAN (0.0/0.0)

// Random number generation state
static int random_initialized = 0;

/**
 * @brief Initialize random number generator
 */
static void init_random(void) {
    if (!random_initialized) {
        srand((unsigned int)time(NULL));
        random_initialized = 1;
    }
}

/**
 * @brief Get random float between 0.0 and 1.0
 */
static double myco_random(void) {
    init_random();
    return (double)rand() / (double)RAND_MAX;
}

/**
 * @brief Get random integer between min and max (inclusive)
 */
static long long myco_randint(long long min, long long max) {
    if (min > max) {
        long long temp = min;
        min = max;
        max = temp;
    }
    init_random();
    return min + (long long)(myco_random() * (max - min + 1));
}

/*******************************************************************************
 * LOOP EXECUTION STATE MANAGEMENT
 ******************************************************************************/

/**
 * @brief Global loop execution state for managing loop safety
 * 
 * This state tracks active loops and enforces safety limits to prevent
 * infinite loops and excessive resource consumption during execution.
 */
static LoopExecutionState* global_loop_state = NULL;

/**
 * @brief Initializes the global loop execution state
 * 
 * Creates and sets up the loop execution state if it doesn't exist.
 * This ensures loop safety features are available during execution.
 */
static void init_loop_execution_state(void) {
    if (!global_loop_state) {
        global_loop_state = create_loop_execution_state();
    }
}

/**
 * @brief Cleans up the global loop execution state
 * 
 * Destroys the loop execution state and frees associated memory.
 * Should be called during interpreter shutdown to prevent memory leaks.
 */
void cleanup_loop_execution_state(void) {
    if (global_loop_state) {
        destroy_loop_execution_state(global_loop_state);
        global_loop_state = NULL;
    }
}

/**
 * @brief Determines if a loop should continue executing
 * @param context The loop context containing iteration state
 * @return 1 if loop should continue, 0 if it should stop
 * 
 * This function implements loop safety logic:
 * - Checks iteration limits to prevent infinite loops
 * - Handles positive and negative step values
 * - Prevents zero-step infinite loops
 * - Ensures loop termination conditions are met
 */
static int should_continue_loop(LoopContext* context) {
    if (!context) return 0;
    
    // Check if we've exceeded the maximum iterations
    if (context->iteration_count >= context->max_iterations) {
        return 0;
    }
    
    // Determine continuation based on step direction
    if (context->step_value > 0) {
        // Positive step: continue while current <= end
        return context->current_value <= context->end_value;
    } else if (context->step_value < 0) {
        // Negative step: continue while current >= end
        return context->current_value >= context->end_value;
    } else {
        // Zero step: never continue (prevent infinite loops)
        return 0;
    }
}

/*******************************************************************************
 * FORWARD DECLARATIONS
 ******************************************************************************/

/**
 * Forward declarations for functions defined later in this file.
 * These are organized by functionality for better code organization.
 */

// Module and function management
static struct ASTNode* find_function_in_module(struct ASTNode* mod, const char* name);
static struct ASTNode* resolve_module(const char* alias);

// Core evaluation functions
long long eval_expression(ASTNode* ast);
void eval_evaluate(ASTNode* ast);

// Function execution
static long long eval_user_function_call(struct ASTNode* fn, struct ASTNode* args_node);

// Variable and string management
static const char* get_str_value(const char* name);

// Add new function for finding functions with module prefix
static ASTNode* find_function_with_module_prefix(const char* module_name, const char* function_name);
static ASTNode* find_function_in_any_module(const char* name);

// ANSI color codes
#define RED "\033[31m"
#define RESET "\033[0m"

/*******************************************************************************
 * ERROR HANDLING SYSTEM
 ******************************************************************************/

/**
 * Myco uses a structured error code system for comprehensive error reporting.
 * 
 * Error Code Structure: 0xMY[SEV][MOD][ERR]
 * - SEV: Severity (0=Info, 1=Warning, 2=Error, F=Fatal)
 * - MOD: Module (0=Runtime, 1=Math, 2=Type, 3=Syntax, 4=IO)
 * - ERR: Specific error code within the module
 * 
 * This system allows for:
 * - Categorized error reporting
 * - Severity-based error handling
 * - Module-specific error recovery
 * - Consistent error format across the interpreter
 */

// Severity levels
#define SEV_INFO    0x00
#define SEV_WARNING 0x01
#define SEV_ERROR   0x02
#define SEV_FATAL   0x0F

// Modules
#define MOD_RUNTIME 0x00
#define MOD_MATH    0x01
#define MOD_TYPE    0x02
#define MOD_SYNTAX  0x03
#define MOD_IO      0x04

// Specific error codes
#define ERR_NONE             0x00
#define ERR_DIVISION_BY_ZERO 0x01
#define ERR_MODULO_BY_ZERO   0x02
#define ERR_UNDEFINED_VAR    0x03
#define ERR_TYPE_MISMATCH    0x04
#define ERR_INVALID_OP       0x05
#define ERR_RECURSION        0x06
#define ERR_FUNC_CALL        0x07
#define ERR_BAD_MEMORY       0x08
#define ERR_INPUT_FAILED     0x09
#define ERR_INVALID_INPUT    0x0A

// Combined error codes
#define ERROR_DIVISION_BY_ZERO   ((SEV_ERROR << 16) | (MOD_MATH << 8) | ERR_DIVISION_BY_ZERO)
#define ERROR_MODULO_BY_ZERO     ((SEV_ERROR << 16) | (MOD_MATH << 8) | ERR_MODULO_BY_ZERO)
#define ERROR_UNDEFINED_VAR      ((SEV_ERROR << 16) | (MOD_RUNTIME << 8) | ERR_UNDEFINED_VAR)
#define ERROR_TYPE_MISMATCH      ((SEV_ERROR << 16) | (MOD_TYPE << 8) | ERR_TYPE_MISMATCH)
#define ERROR_INVALID_OP         ((SEV_ERROR << 16) | (MOD_RUNTIME << 8) | ERR_INVALID_OP)
#define ERROR_RECURSION          ((SEV_ERROR << 16) | (MOD_RUNTIME << 8) | ERR_RECURSION)
#define ERROR_FUNC_CALL          ((SEV_ERROR << 16) | (MOD_RUNTIME << 8) | ERR_FUNC_CALL)
#define ERROR_BAD_MEMORY         ((SEV_FATAL << 16) | (MOD_RUNTIME << 8) | ERR_BAD_MEMORY)
#define ERROR_INPUT_FAILED       ((SEV_ERROR << 16) | (MOD_IO << 8) | ERR_INPUT_FAILED)
#define ERROR_INVALID_INPUT      ((SEV_ERROR << 16) | (MOD_IO << 8) | ERR_INVALID_INPUT)

#ifdef _WIN32
  #define strcasecmp _stricmp
#else
  #include <strings.h> // for strcasecmp
#endif

// Error messages
static const char* error_messages[] = {
    "No error",
    "Division by zero",
    "Modulo by zero",
    "Undefined variable",
    "Type mismatch",
    "Invalid operation",
    "Recursion error",
    "Function call error",
    "Bad memory access"
};

// Helper to check if a string is a string literal (starts and ends with ")
static int is_string_literal(const char* text) {
    if (!text) return 0;
    size_t len = strlen(text);
    return len >= 2 && text[0] == '"' && text[len-1] == '"';
}

// Helper function to check if a variable exists
int var_exists(const char* name);

// Helper function to check if a node represents a string
static int is_string_node(ASTNode* node) {
    if (!node) return 0;
    
    // If it's a string literal (quoted text), it's a string
    if (node->type == AST_EXPR && node->text && is_string_literal(node->text)) {
        return 1;
    }
    
    // If it's a variable, check if it's a string variable
    if (node->type == AST_EXPR && node->text) {
        // First check if it's a numeric variable
        if (var_exists(node->text)) {
            return 0; // It's a numeric variable, not a string
        }
        // Then check if it's a string variable
        const char* str_val = get_str_value(node->text);
        if (str_val) {
            return 1;
        }
    }
    
    // Everything else is not a string
    return 0;
}

// Enhanced variable environment: supports numbers, strings, arrays, and objects
typedef struct {
    char* name;
    enum {
        VAR_TYPE_NUMBER,
        VAR_TYPE_FLOAT,
        VAR_TYPE_STRING,
        VAR_TYPE_ARRAY,
        VAR_TYPE_OBJECT,
        VAR_TYPE_SET,
        VAR_TYPE_LAMBDA
    } type;
    long long number_value;
    double float_value;
    char* string_value;
    MycoArray* array_value;
    MycoObject* object_value;
    MycoSet* set_value;
    ASTNode* lambda_value;
} VarEntry;

static VarEntry* var_env = NULL;
static int var_env_size = 0;
static int var_env_capacity = 0;

// String variable environment
typedef struct {
    char* name;
    char* value;
} StrEntry;
static StrEntry* str_env = NULL;
static int str_env_size = 0;
static int str_env_capacity = 0;

// Global variable to store the last string concatenation result
static char* last_concat_result = NULL;

// Global variable to track if the last expression result was a float
static int last_result_is_float = 0;

// Global object reference for chained property access
static MycoObject* __chained_object_ref = NULL;

// Simple module alias mapping
typedef struct {
    char* alias;
    ASTNode* module_ast;
} ModuleEntry;
static ModuleEntry* modules = NULL;
static int modules_size = 0;
static int modules_cap = 0;

// Base directory for resolving relative module paths
static char base_dir[1024] = "";
void eval_set_base_dir(const char* dir) {
    if (!dir) { base_dir[0] = '\0'; return; }
    size_t n = strlen(dir);
    if (n >= sizeof(base_dir)) n = sizeof(base_dir) - 1;
    strncpy(base_dir, dir, n);
    base_dir[n] = '\0';
}

static void compute_full_path(const char* path, char* out, size_t out_size) {
    const char* rel = path;
    if (rel[0] == '.' && rel[1] == '/') rel = rel + 2;
    
    // Add .myco extension if it's missing
    char path_with_ext[1024];
    if (strlen(rel) > 5 && strcmp(rel + strlen(rel) - 5, ".myco") == 0) {
        // Already has .myco extension
        strncpy(path_with_ext, rel, sizeof(path_with_ext) - 1);
        path_with_ext[sizeof(path_with_ext) - 1] = '\0';
    } else {
        // Add .myco extension
        snprintf(path_with_ext, sizeof(path_with_ext), "%s.myco", rel);
    }
    
    // Always use base_dir for relative paths
    if (base_dir[0]) {
        snprintf(out, out_size, "%s/%s", base_dir, path_with_ext);
    } else {
        // If no base_dir, use current directory
        snprintf(out, out_size, "./%s", path_with_ext);
    }
    
    
}

// Global function registry
typedef struct {
    char* name;
    ASTNode* func_ast; // points to AST_FUNC node
} FuncEntry;
static FuncEntry* functions = NULL;
static int functions_size = 0;
static int functions_cap = 0;

// Scope stack for function calls
typedef struct {
    int var_env_start;  // Starting index in var_env for this scope
    int str_env_start;  // Starting index in str_env for this scope
} ScopeEntry;
static ScopeEntry* scope_stack = NULL;
static int scope_stack_size = 0;
static int scope_stack_capacity = 0;

// Scope management functions
static void push_scope() {
    if (scope_stack_size >= scope_stack_capacity) {
        int new_capacity = scope_stack_capacity ? scope_stack_capacity * 2 : 8;
        ScopeEntry* new_stack = (ScopeEntry*)tracked_realloc(scope_stack, new_capacity * sizeof(ScopeEntry), __FILE__, __LINE__, "expand_scope_stack");
        if (!new_stack) {
            fprintf(stderr, "Error: Failed to expand scope stack\n");
            return;
        }
        scope_stack = new_stack;
        scope_stack_capacity = new_capacity;
    }
    
    scope_stack[scope_stack_size].var_env_start = var_env_size;
    scope_stack[scope_stack_size].str_env_start = str_env_size;
    scope_stack_size++;
}

static void pop_scope() {
    if (scope_stack_size > 0) {
        scope_stack_size--;
        ScopeEntry* scope = &scope_stack[scope_stack_size];
        
        // Remove variables from this scope
        while (var_env_size > scope->var_env_start) {
            var_env_size--;
            if (var_env[var_env_size].name) {
                // Clean up array variables if they exist
            if (var_env[var_env_size].type == VAR_TYPE_ARRAY && var_env[var_env_size].array_value) {
                destroy_array(var_env[var_env_size].array_value);
                var_env[var_env_size].array_value = NULL;
            }
            
            // Clean up object variables if they exist
            if (var_env[var_env_size].type == VAR_TYPE_OBJECT && var_env[var_env_size].object_value) {
                destroy_object(var_env[var_env_size].object_value);
                var_env[var_env_size].object_value = NULL;
            }
                tracked_free(var_env[var_env_size].name, __FILE__, __LINE__, "pop_scope_var");
                var_env[var_env_size].name = NULL;
            }
        }
        
        // Remove string variables from this scope
        while (str_env_size > scope->str_env_start) {
            str_env_size--;
            if (str_env[str_env_size].name) {
                tracked_free(str_env[str_env_size].name, __FILE__, __LINE__, "pop_scope_str");
                str_env[str_env_size].name = NULL;
            }
        }
    }
}

// Discord Gateway minimal state
#ifndef _WIN32
static int gw_in_fd = -1;
static int gw_out_fd = -1;
static FILE* gw_in = NULL;
static FILE* gw_out = NULL;
#endif
static int gw_seq = -1;
static int gw_heartbeat_ms = 0;

#ifndef _WIN32
static int file_executable(const char* p) {
    return (p && access(p, X_OK) == 0);
}

static int ensure_dir(const char* path) {
    struct stat st; if (stat(path, &st) == 0) return 0; return mkdir(path, 0700);
}

static int ensure_websocat(char* out_path, size_t out_sz) {
    const char* env = getenv("MYCO_WEBSOCAT");
    if (env && env[0] && file_executable(env)) {
        snprintf(out_path, out_sz, "%s", env);
        return 0;
    }

    // Check local tool in ~/.myco/bin
    const char* rel_dir = ".myco/bin";
    (void)ensure_dir(".myco"); (void)ensure_dir(rel_dir);
    char local_bin[512]; snprintf(local_bin, sizeof(local_bin), "%s/websocat", rel_dir);
    if (file_executable(local_bin)) {
        snprintf(out_path, out_sz, "%s", local_bin);
        return 0;
    }

    // Opt-in fetch only
    const char* fetch = getenv("MYCO_FETCH_DEPS");
    if (fetch && (strcmp(fetch,"1")==0 || strcasecmp(fetch,"true")==0)) {
        // TODO: safe downloader + SHA-256 verify before chmod/exec
        fprintf(stderr,
            "[myco] error: automatic dependency fetch disabled until checksum verification is implemented.\n"
            "Set MYCO_WEBSOCAT to a trusted binary path, or install websocat manually.\n");
        return -2;
    }

    // Default: fail with actionable instructions
    fprintf(stderr,
        "[myco] missing dependency: websocat\n"
        " - Set MYCO_WEBSOCAT=/path/to/websocat\n"
        " - Or install to ~/.myco/bin/websocat (chmod +x)\n"
        " - Recommended source: https://github.com/vi/websocat/releases (verify checksum)\n");
    return -1;
}


static int gateway_spawn_websocat(const char* url) {
    int inpipe[2];
    int outpipe[2];
    if (pipe(inpipe) != 0) return -1;
    if (pipe(outpipe) != 0) { close(inpipe[0]); close(inpipe[1]); return -1; }
    pid_t pid = fork();
    if (pid < 0) { close(inpipe[0]); close(inpipe[1]); close(outpipe[0]); close(outpipe[1]); return -1; }
    if (pid == 0) {
        // child
        dup2(inpipe[0], STDIN_FILENO);
        dup2(outpipe[1], STDOUT_FILENO);
        close(inpipe[1]); close(outpipe[0]);
        close(inpipe[0]); close(outpipe[1]);
        char binbuf[512]; const char* bin = getenv("MYCO_WEBSOCAT");
        if (!bin || !bin[0]) {
            if (ensure_websocat(binbuf, sizeof(binbuf)) == 0) bin = binbuf; else bin = "websocat";
        }
        execlp(bin, bin, "-t", url, (char*)NULL);
        _exit(127);
    }
    // parent
    close(inpipe[0]); close(outpipe[1]);
    gw_in_fd = inpipe[1];
    gw_out_fd = outpipe[0];
    gw_in = fdopen(gw_in_fd, "w");
    gw_out = fdopen(gw_out_fd, "r");
    setvbuf(gw_in, NULL, _IONBF, 0);
    setvbuf(gw_out, NULL, _IONBF, 0);
    return 0;
}
#endif

static void register_function(const char* name, ASTNode* fn) {
    if (!name || !fn) return;
    
    // Check if function already exists
    for (int i = functions_size - 1; i >= 0; i--) {
        if (strcmp(functions[i].name, name) == 0) {
            // Function already exists, update it
            functions[i].func_ast = fn;
            return;
        }
    }
    
    // Expand capacity if needed
    if (functions_size >= functions_cap) {
        int new_cap = functions_cap ? functions_cap * 2 : 8;
        FuncEntry* new_funcs = (FuncEntry*)tracked_realloc(functions, new_cap * sizeof(FuncEntry), __FILE__, __LINE__, "expand_functions");
        if (!new_funcs) {
            // Handle realloc failure
            return;
        }
        functions = new_funcs;
        functions_cap = new_cap;
    }
    
    // Add new function
    functions[functions_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    if (functions[functions_size].name) {
        functions[functions_size].func_ast = fn;
        functions_size++;
    }
}

static ASTNode* find_function_global(const char* name) {
    if (!name) return NULL;
    for (int i = functions_size - 1; i >= 0; i--) {
        if (strcmp(functions[i].name, name) == 0) return functions[i].func_ast;
    }
    // fallback: search modules directly
    for (int mi = 0; mi < modules_size; mi++) {
        ASTNode* fn = find_function_in_module(modules[mi].module_ast, name);
        if (fn) return fn;
    }
    return NULL;
}

// Error handling state
static int in_try_block = 0;
static int in_catch_block = 0; // NEW: track when evaluating catch body
static int error_occurred = 0;
static int error_value = 0;
static int error_printed = 0;

// Function return handling
static int return_flag = 0;
static long long return_value = 0;

// Global variables for tracking state
static int loop_counter = 0;

// Add global variable for current line
static int current_line = 1;

// Helper function to get error description
static const char* get_error_description(int error_code) {
    // Map error codes to descriptions
    switch (error_code) {
        case ERROR_DIVISION_BY_ZERO: return "division by zero";
        case ERROR_MODULO_BY_ZERO:   return "modulo by zero";
        case ERROR_UNDEFINED_VAR:    return "undefined variable";
        case ERROR_TYPE_MISMATCH:    return "type mismatch";
        case ERROR_INVALID_OP:       return "invalid operation";
        case ERROR_RECURSION:        return "recursion error";
        case ERROR_FUNC_CALL:        return "function call error";
        case ERROR_BAD_MEMORY:       return "bad memory access";
        case ERROR_INPUT_FAILED:     return "input failed";
        case ERROR_INVALID_INPUT:    return "invalid input";
        default:                     return "unknown error";
    }
}

// Helper function to format error message with proper error code
static void format_error_message(int error_code, int line, char* buffer, size_t size) {
    if (in_catch_block) {
        // For catch blocks: just the description
        snprintf(buffer, size, "%s%s%s", RED, get_error_description(error_code), RESET);
    } else {
        // Regular runtime report: include line
        const char* desc = get_error_description(error_code);
        char cap[256];
        strncpy(cap, desc, sizeof(cap) - 1);
        cap[sizeof(cap) - 1] = '\0';
        if (cap[0]) cap[0] = (char)toupper((unsigned char)cap[0]);
        snprintf(buffer, size, "%sLine %d: %s%s", RED, line, cap, RESET);
    }
}

// Helper function to set error state
static void set_error(int error_code) {
    error_occurred = 1;
    error_value = error_code;
    if (!in_try_block && !error_printed) {
        char error_msg[256];
        format_error_message(error_code, current_line, error_msg, sizeof(error_msg));
        fprintf(stderr, "%s\n", error_msg);
        error_printed = 1;
    }
}

// Helper function to handle error in catch block
static void handle_catch_error(int error_code) {
    char error_msg[256];
    format_error_message(error_code, current_line, error_msg, sizeof(error_msg));
    printf("%s\n", error_msg);
}

// Helper function to reset error state
static void reset_error_state() {
    error_occurred = 0;
    error_value = 0;
    error_printed = 0;
}

// Helper function to get a variable's value from the environment
static long long get_var_value(const char* name) {
    // Search from the end (most recent variables first) to prioritize function parameters
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (var_env[i].name && strcmp(var_env[i].name, name) == 0) {
            if (var_env[i].type == VAR_TYPE_NUMBER) {
                return var_env[i].number_value;
            } else if (var_env[i].type == VAR_TYPE_FLOAT) {
                // Return scaled float for compatibility with integer system
                return (long long)(var_env[i].float_value * 1000000);
            } else if (var_env[i].type == VAR_TYPE_ARRAY) {
                // Return special value to indicate this is an array variable
                return -2; // Special value to indicate array variable
            } else if (var_env[i].type == VAR_TYPE_OBJECT) {
                // Return special value to indicate this is an object variable
                return -3; // Special value to indicate object variable
            }
            // String variables return 0 (as before)
            return 0;
        }
    }
    return 0;
}

// Helper function to get a float variable's value from the environment
static double get_float_value(const char* name) {
    // Search from the end (most recent variables first) to prioritize function parameters
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (var_env[i].name && strcmp(var_env[i].name, name) == 0) {
            if (var_env[i].type == VAR_TYPE_FLOAT) {
                return var_env[i].float_value;
            } else if (var_env[i].type == VAR_TYPE_NUMBER) {
                return (double)var_env[i].number_value;
            }
            return 0.0;
        }
    }
    return 0.0;
}

// Helper function to set a float variable's value in the environment
void set_float_value(const char* name, double value) {
    // Check if variable already exists
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (strcmp(var_env[i].name, name) == 0) {
            // Update existing variable
            if (var_env[i].type == VAR_TYPE_ARRAY && var_env[i].array_value) {
                destroy_array(var_env[i].array_value);
                var_env[i].array_value = NULL;
            }
            if (var_env[i].type == VAR_TYPE_OBJECT && var_env[i].object_value) {
                destroy_object(var_env[i].object_value);
                var_env[i].object_value = NULL;
            }
            var_env[i].type = VAR_TYPE_FLOAT;
            var_env[i].float_value = value;
            var_env[i].number_value = 0;
            var_env[i].string_value = NULL;
            var_env[i].array_value = NULL;
            var_env[i].object_value = NULL;
            return;
        }
    }
    
    // Expand capacity if needed
    if (var_env_size >= var_env_capacity) {
        int new_capacity = var_env_capacity ? var_env_capacity * 2 : 8;
        VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_float");
        if (!new_env) {
            // Handle realloc failure
            return;
        }
        var_env = new_env;
        var_env_capacity = new_capacity;
    }
    
    // Add new variable
    var_env[var_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    if (var_env[var_env_size].name) {
        var_env[var_env_size].type = VAR_TYPE_FLOAT;
        var_env[var_env_size].float_value = value;
        var_env[var_env_size].number_value = 0;
        var_env[var_env_size].string_value = NULL;
        var_env[var_env_size].array_value = NULL;
        var_env[var_env_size].object_value = NULL;
        var_env_size++;
    }
}

// Helper function to set a variable's value in the environment
void set_var_value(const char* name, long long value) {
    // Check if variable already exists
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (strcmp(var_env[i].name, name) == 0) {
            // Update existing variable
            if (var_env[i].type == VAR_TYPE_ARRAY && var_env[i].array_value) {
                destroy_array(var_env[i].array_value);
                var_env[i].array_value = NULL;
            }
            if (var_env[i].type == VAR_TYPE_OBJECT && var_env[i].object_value) {
                destroy_object(var_env[i].object_value);
                var_env[i].object_value = NULL;
            }
            var_env[i].type = VAR_TYPE_NUMBER;
            var_env[i].number_value = value;
            var_env[i].string_value = NULL;
            var_env[i].array_value = NULL;
            var_env[i].object_value = NULL;
            return;
        }
    }
    
    // Expand capacity if needed
    if (var_env_size >= var_env_capacity) {
        int new_capacity = var_env_capacity ? var_env_capacity * 2 : 8;
        VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_number");
        if (!new_env) {
            // Handle realloc failure
            return;
        }
        var_env = new_env;
        var_env_capacity = new_capacity;
    }
    
    // Add new variable
    var_env[var_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    if (var_env[var_env_size].name) {
        var_env[var_env_size].type = VAR_TYPE_NUMBER;
        var_env[var_env_size].number_value = value;
        var_env[var_env_size].string_value = NULL;
        var_env[var_env_size].array_value = NULL;
        var_env[var_env_size].object_value = NULL;
        var_env_size++;
    }
}

// Helper function to set an array variable in the environment
void set_array_value(const char* name, MycoArray* array) {
    if (!name || !array) return;
    
    // Check if variable already exists
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (strcmp(var_env[i].name, name) == 0) {
            // Update existing variable
            if (var_env[i].type == VAR_TYPE_ARRAY && var_env[i].array_value) {
                destroy_array(var_env[i].array_value);
            }
            var_env[i].type = VAR_TYPE_ARRAY;
            var_env[i].array_value = array;
            var_env[i].number_value = 0;
            var_env[i].string_value = NULL;
            var_env[i].object_value = NULL;
            return;
        }
    }
    
    // Expand capacity if needed
    if (var_env_size >= var_env_capacity) {
        int new_capacity = var_env_capacity ? var_env_capacity * 2 : 8;
        VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_array");
        if (!new_env) {
            // Handle realloc failure
            return;
        }
        var_env = new_env;
        var_env_capacity = new_capacity;
    }
    
    // Add new variable
    var_env[var_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    if (var_env[var_env_size].name) {
        var_env[var_env_size].type = VAR_TYPE_ARRAY;
        var_env[var_env_size].array_value = array;
        var_env[var_env_size].number_value = 0;
        var_env[var_env_size].string_value = NULL;
        var_env[var_env_size].object_value = NULL;
        var_env_size++;
    }
}

/**
 * @brief Gets an element from an array at the specified index
 * @param array The array to access
 * @param index The index of the element
 * @return Pointer to the element, or NULL if invalid
 */
void* array_get(MycoArray* array, int index) {
    if (!array || index < 0 || index >= array->size) return NULL;
    
    if (array->is_string_array) {
        return array->str_elements[index];
    } else {
        // Return pointer to the number (caller must cast appropriately)
        return &array->elements[index];
    }
}

/**
 * @brief Gets a string element from an array at the specified index
 * @param array The array to access
 * @param index The index of the element
 * @return Pointer to the string, or NULL if invalid or not a string array
 */
const char* array_get_string(MycoArray* array, int index) {
    if (!array || !array->is_string_array || index < 0 || index >= array->size) return NULL;
    return array->str_elements[index];
}

// Helper function to check if a variable exists
int var_exists(const char* name) {
    for (int i = 0; i < var_env_size; i++) {
        if (strcmp(var_env[i].name, name) == 0) {
            return 1;
        }
    }
    return 0;
}

static const char* get_str_value(const char* name) {
    for (int i = str_env_size - 1; i >= 0; i--) {
        if (strcmp(str_env[i].name, name) == 0) return str_env[i].value;
    }
    return NULL;
}

static void set_str_value(const char* name, const char* value) {
    // Safety check: ensure name is not NULL
    if (!name) {
        return;
    }
    
    // Check if variable already exists
    for (int i = str_env_size - 1; i >= 0; i--) {
        if (strcmp(str_env[i].name, name) == 0) {
            // Update existing variable
            if (str_env[i].value) {
                free(str_env[i].value);
                str_env[i].value = NULL; // Prevent double-free
            }
            // Create a safe copy of the value
            const char* safe_value = value ? value : "";
            str_env[i].value = tracked_strdup(safe_value, __FILE__, __LINE__, "eval");
            if (!str_env[i].value) {
                // Handle strdup failure
                str_env[i].value = tracked_strdup("", __FILE__, __LINE__, "eval");
            }
            return;
        }
    }
    
    // Expand capacity if needed
    if (str_env_size >= str_env_capacity) {
        int new_capacity = str_env_capacity ? str_env_capacity * 2 : 8;
        StrEntry* new_env = (StrEntry*)tracked_realloc(str_env, new_capacity * sizeof(StrEntry), __FILE__, __LINE__, "set_str_value");
        if (!new_env) {
            // Handle realloc failure
            return;
        }
        str_env = new_env;
        str_env_capacity = new_capacity;
    }
    
    // Add new variable
    str_env[str_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    str_env[str_env_size].value = tracked_strdup(value ? value : "", __FILE__, __LINE__, "eval");
    if (str_env[str_env_size].name && str_env[str_env_size].value) {
        str_env_size++;
    } else {
        // Handle allocation failure
        if (str_env[str_env_size].name) {
            tracked_free(str_env[str_env_size].name, __FILE__, __LINE__, "set_str_value");
            str_env[str_env_size].name = NULL;
        }
        if (str_env[str_env_size].value) {
            tracked_free(str_env[str_env_size].value, __FILE__, __LINE__, "set_str_value");
            str_env[str_env_size].value = NULL;
        }
    }
}

// Helper function to set a lambda function variable in the environment
void set_lambda_value(const char* name, ASTNode* lambda_ast) {
    if (!name || !lambda_ast) return;
    
    // Check if variable already exists
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (strcmp(var_env[i].name, name) == 0) {
            // Update existing variable
            if (var_env[i].type == VAR_TYPE_ARRAY && var_env[i].array_value) {
                destroy_array(var_env[i].array_value);
                var_env[i].array_value = NULL;
            }
            if (var_env[i].type == VAR_TYPE_OBJECT && var_env[i].object_value) {
                destroy_object(var_env[i].object_value);
                var_env[i].object_value = NULL;
            }
            if (var_env[i].type == VAR_TYPE_LAMBDA && var_env[i].lambda_value) {
                // Note: We don't free lambda_ast as it's owned by the parser
                var_env[i].lambda_value = NULL;
            }
            var_env[i].type = VAR_TYPE_LAMBDA;
            var_env[i].lambda_value = lambda_ast;
            var_env[i].number_value = 0;
            var_env[i].string_value = NULL;
            var_env[i].array_value = NULL;
            var_env[i].object_value = NULL;
            var_env[i].set_value = NULL;
            return;
        }
    }
    
    // Expand capacity if needed
    if (var_env_size >= var_env_capacity) {
        int new_capacity = var_env_capacity ? var_env_capacity * 2 : 8;
        VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_lambda");
        if (!new_env) {
            // Handle realloc failure
            return;
        }
        var_env = new_env;
        var_env_capacity = new_capacity;
    }
    
    // Add new variable
            var_env[var_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
        if (var_env[var_env_size].name) {
            var_env[var_env_size].type = VAR_TYPE_LAMBDA;
            var_env[var_env_size].lambda_value = lambda_ast;
            var_env[var_env_size].number_value = 0;
            var_env[var_env_size].string_value = NULL;
            var_env[var_env_size].array_value = NULL;
            var_env[var_env_size].object_value = NULL;
            var_env[var_env_size].set_value = NULL;
            var_env_size++;
        }
}

// Helper function to get a lambda function from the environment
ASTNode* get_lambda_value(const char* name) {
    if (!name) return NULL;
    
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (strcmp(var_env[i].name, name) == 0 && var_env[i].type == VAR_TYPE_LAMBDA) {
            return var_env[i].lambda_value;
        }
    }
    return NULL;
}

// Helper function to execute a lambda function
long long execute_lambda(ASTNode* lambda_ast, ASTNode* args_node) {
    if (!lambda_ast || lambda_ast->type != AST_LAMBDA || lambda_ast->child_count < 2) {
        return 0;
    }
    
    // Get parameters and body
    ASTNode* params = &lambda_ast->children[0];
    ASTNode* body = &lambda_ast->children[1];
    

    
    // Handle single parameter lambda
    if (params->type == AST_EXPR && params->text && strcmp(params->text, "params") != 0 && 
        args_node && args_node->child_count > 0) {
        // Single parameter lambda: x => expression
        char* param_name = params->text;
        if (param_name) {
            // Evaluate the argument
            long long arg_value = eval_expression(&args_node->children[0]);
            
            // Store parameter in current scope
            set_var_value(param_name, arg_value);
            
            // Execute lambda body
            long long result = eval_expression(body);
            
            return result;
        }
    }
    // Handle no-parameter lambda
    else if (params->type == AST_EXPR && params->text && strcmp(params->text, "params") == 0 && 
             params->child_count == 0 && (!args_node || args_node->child_count == 0)) {
        // No-parameter lambda: () => expression
        // Execute lambda body directly
        long long result = eval_expression(body);
        
        return result;
    }
    // Handle multiple parameter lambda
    if (params->type == AST_EXPR && params->text && strcmp(params->text, "params") == 0 && 
        params->child_count > 0 && args_node && args_node->child_count > 0) {
        // Multiple parameters lambda: (x, y) => expression
        
        // Check if we have enough arguments
        if (args_node->child_count < params->child_count) {
            fprintf(stderr, "Error: Lambda expects %d parameters but got %d arguments\n", 
                    params->child_count, args_node->child_count);
            return 0;
        }
        
        // Bind each parameter to its argument
        for (int i = 0; i < params->child_count; i++) {
            if (i < args_node->child_count) {
                char* param_name = params->children[i].text;
                if (param_name) {
                    // Evaluate the argument
                    long long arg_value = eval_expression(&args_node->children[i]);
                    
                    // Store parameter in current scope
                    set_var_value(param_name, arg_value);
                }
            }
        }
        
        // Execute lambda body
        long long result = eval_expression(body);
        
        return result;
    }
    
    return 0;
}

// Cleanup function for string environment
static void cleanup_str_env() {
    if (str_env && str_env_size > 0) {
        for (int i = 0; i < str_env_size; i++) {
            if (str_env[i].name) {
                tracked_free(str_env[i].name, __FILE__, __LINE__, "cleanup_str_env");
                str_env[i].name = NULL;
            }
            if (str_env[i].value) {
                tracked_free(str_env[i].value, __FILE__, __LINE__, "cleanup_str_env");
                str_env[i].value = NULL;
            }
        }
        tracked_free(str_env, __FILE__, __LINE__, "cleanup_str_env");
        str_env = NULL;
        str_env_size = 0;
        str_env_capacity = 0;
    }
}

// Cleanup function for variable environment
static void cleanup_var_env() {
    if (var_env && var_env_size > 0) {
    for (int i = 0; i < var_env_size; i++) {
                    if (var_env[i].name) {
            tracked_free(var_env[i].name, __FILE__, __LINE__, "cleanup_var_env");
            var_env[i].name = NULL;
        }
    }
    tracked_free(var_env, __FILE__, __LINE__, "cleanup_var_env");
    var_env = NULL;
    var_env_size = 0;
    var_env_capacity = 0;
    }
}

/*******************************************************************************
 * ARRAY MANAGEMENT FUNCTIONS
 ******************************************************************************/

/**
 * @brief Creates a new array with specified capacity and type
 * @param initial_capacity Initial capacity for the array
 * @param is_string_array 1 for string array, 0 for number array
 * @return New array instance, or NULL on failure
 */
MycoArray* create_array(int initial_capacity, int is_string_array) {
    if (initial_capacity <= 0) initial_capacity = 8;
    
    MycoArray* array = (MycoArray*)tracked_malloc(sizeof(MycoArray), __FILE__, __LINE__, "create_array");
    if (!array) return NULL;
    
    array->capacity = initial_capacity;
    array->size = 0;
    array->is_string_array = is_string_array;
    
    if (is_string_array) {
        array->str_elements = (char**)tracked_malloc(initial_capacity * sizeof(char*), __FILE__, __LINE__, "create_array_str");
        array->elements = NULL;
        if (!array->str_elements) {
            tracked_free(array, __FILE__, __LINE__, "create_array_str_fail");
            return NULL;
        }
        // Initialize string pointers to NULL
        for (int i = 0; i < initial_capacity; i++) {
            array->str_elements[i] = NULL;
        }
    } else {
        array->elements = (long long*)tracked_malloc(initial_capacity * sizeof(long long), __FILE__, __LINE__, "create_array_num");
        array->str_elements = NULL;
        if (!array->elements) {
            tracked_free(array, __FILE__, __LINE__, "create_array_num_fail");
            return NULL;
        }
        // Initialize numbers to 0
        for (int i = 0; i < initial_capacity; i++) {
            array->elements[i] = 0;
        }
    }
    
    return array;
}

/**
 * @brief Destroys an array and frees all associated memory
 * @param array The array to destroy
 */
void destroy_array(MycoArray* array) {
    if (!array) return;
    
    if (array->is_string_array && array->str_elements) {
        // Free all string elements
        for (int i = 0; i < array->size; i++) {
            if (array->str_elements[i]) {
                tracked_free(array->str_elements[i], __FILE__, __LINE__, "destroy_array_str");
            }
        }
        tracked_free(array->str_elements, __FILE__, __LINE__, "destroy_array_str_array");
    } else if (array->elements) {
        tracked_free(array->elements, __FILE__, __LINE__, "destroy_array_num_array");
    }
    
    tracked_free(array, __FILE__, __LINE__, "destroy_array");
}

/**
 * @brief Adds an element to the end of an array
 * @param array The array to modify
 * @param element The element to add
 * @return 1 on success, 0 on failure
 */
int array_push(MycoArray* array, void* element) {
    if (!array || !element) return 0;
    
    // Expand capacity if needed
    if (array->size >= array->capacity) {
        int new_capacity = array->capacity * 2;
        if (array->is_string_array) {
            char** new_elements = (char**)tracked_realloc(array->str_elements, new_capacity * sizeof(char*), __FILE__, __LINE__, "array_push_str");
            if (!new_elements) return 0;
            array->str_elements = new_elements;
            // Initialize new elements to NULL
            for (int i = array->capacity; i < new_capacity; i++) {
                array->str_elements[i] = NULL;
            }
        } else {
            long long* new_elements = (long long*)tracked_realloc(array->elements, new_capacity * sizeof(long long), __FILE__, __LINE__, "array_push_num");
            if (!new_elements) return 0;
            array->elements = new_elements;
        }
        array->capacity = new_capacity;
    }
    
    // Add the element
    if (array->is_string_array) {
        array->str_elements[array->size] = tracked_strdup((char*)element, __FILE__, __LINE__, "eval");
    } else {
        array->elements[array->size] = *(long long*)element;
    }
    array->size++;
    
    return 1;
}

/**
 * @brief Sets an element in an array at the specified index
 * @param array The array to modify
 * @param index The index to set
 * @param element The new element value
 * @return 1 on success, 0 on failure
 */
int array_set(MycoArray* array, int index, void* element) {
    if (!array || !element || index < 0 || index >= array->size) return 0;
    
    if (array->is_string_array) {
        // Free old string if it exists
        if (array->str_elements[index]) {
            tracked_free(array->str_elements[index], __FILE__, __LINE__, "array_set_str");
        }
        array->str_elements[index] = tracked_strdup((char*)element, __FILE__, __LINE__, "eval");
    } else {
        array->elements[index] = *(long long*)element;
    }
    
    return 1;
}

/**
 * @brief Gets the current size of an array
 * @param array The array to check
 * @return Number of elements in the array
 */
int array_size(MycoArray* array) {
    return array ? array->size : 0;
}

/**
 * @brief Gets the current capacity of an array
 * @param array The array to check
 * @return Current allocated capacity
 */
int array_capacity(MycoArray* array) {
    return array ? array->capacity : 0;
}

/**
 * @brief Creates a new object with the specified initial capacity
 * @param initial_capacity The initial capacity for the object
 * @return Pointer to the created object, or NULL on failure
 */
MycoObject* create_object(int initial_capacity) {
    MycoObject* obj = (MycoObject*)tracked_malloc(sizeof(MycoObject), __FILE__, __LINE__, "create_object");
    if (!obj) return NULL;
    
    obj->property_names = (char**)tracked_malloc(initial_capacity * sizeof(char*), __FILE__, __LINE__, "create_object_names");
    if (!obj->property_names) {
        tracked_free(obj, __FILE__, __LINE__, "create_object_names_fail");
        return NULL;
    }
    
    obj->property_values = (void**)tracked_malloc(initial_capacity * sizeof(void*), __FILE__, __LINE__, "create_object_values");
    if (!obj->property_values) {
        tracked_free(obj->property_names, __FILE__, __LINE__, "create_object_values_fail");
        tracked_free(obj, __FILE__, __LINE__, "create_object_values_fail");
        return NULL;
    }
    
    obj->property_types = (PropertyType*)tracked_malloc(initial_capacity * sizeof(PropertyType), __FILE__, __LINE__, "create_object_types");
    if (!obj->property_types) {
        tracked_free(obj->property_values, __FILE__, __LINE__, "create_object_types_fail");
        tracked_free(obj->property_names, __FILE__, __LINE__, "create_object_types_fail");
        tracked_free(obj, __FILE__, __LINE__, "create_object_types_fail");
        return NULL;
    }
    
    // Initialize all properties to NULL
    for (int i = 0; i < initial_capacity; i++) {
        obj->property_names[i] = NULL;
        obj->property_values[i] = NULL;
        obj->property_types[i] = PROP_TYPE_NUMBER; // Default type
    }
    
    obj->property_count = 0;
    obj->capacity = initial_capacity;
    obj->is_method = 0;
    
    return obj;
}

/**
 * @brief Creates an object from an AST_OBJECT_LITERAL node (recursive helper)
 * @param ast The AST_OBJECT_LITERAL node to process
 * @return Pointer to the created object, or NULL on failure
 */
MycoObject* create_object_from_literal(ASTNode* ast) {
    if (!ast || ast->type != AST_OBJECT_LITERAL) {
        return NULL;
    }
    
    // Create object with appropriate capacity
    MycoObject* obj = create_object(ast->child_count);
    if (!obj) {
        return NULL;
    }
    
    // Add properties to the object
    for (int i = 0; i < ast->child_count; i++) {
        if (ast->children[i].type == AST_EXPR && 
            ast->children[i].text && 
            strcmp(ast->children[i].text, "prop") == 0 &&
            ast->children[i].child_count == 2) {
            
            // Get property name
            char* prop_name = ast->children[i].children[0].text;
            if (!prop_name) continue;
            
            // Handle property value based on its type
            if (ast->children[i].children[1].type == AST_OBJECT_LITERAL) {
                // Recursive case: nested object literal
                MycoObject* nested_obj = create_object_from_literal(&ast->children[i].children[1]);
                if (nested_obj) {
                    object_set_property_typed(obj, prop_name, nested_obj, PROP_TYPE_OBJECT);
                } else {
                    object_set_property_typed(obj, prop_name, (void*)0, PROP_TYPE_NUMBER);
                }
            } else if (ast->children[i].children[1].type == AST_EXPR && 
                       ast->children[i].children[1].text &&
                       ast->children[i].children[1].text[0] == '"') {
                // String literal
                char* str_value = ast->children[i].children[1].text;
                if (strlen(str_value) >= 2) {
                    char* clean_str = tracked_strdup(str_value + 1, __FILE__, __LINE__, "eval"); // Skip first quote
                    clean_str[strlen(clean_str) - 1] = '\0'; // Remove last quote
                    object_set_property_typed(obj, prop_name, clean_str, PROP_TYPE_STRING);
                } else {
                    object_set_property_typed(obj, prop_name, strdup(""), PROP_TYPE_STRING);
                }
            } else {
                // Evaluate as expression (number)
                long long prop_value = eval_expression(&ast->children[i].children[1]);
                object_set_property_typed(obj, prop_name, (void*)(long long)prop_value, PROP_TYPE_NUMBER);
            }
        }
    }
    
    return obj;
}

/**
 * @brief Destroys an object and frees all associated memory
 * @param obj The object to destroy
 */
void destroy_object(MycoObject* obj) {
    if (!obj) return;
    
    // Free all property names and values
    for (int i = 0; i < obj->property_count; i++) {
        if (obj->property_names[i]) {
            tracked_free(obj->property_names[i], __FILE__, __LINE__, "destroy_object_name");
        }
        // Note: property values are not freed here as they may be shared
        // (e.g., strings from variables, arrays from variables)
    }
    
    // Free the arrays
    if (obj->property_names) {
        tracked_free(obj->property_names, __FILE__, __LINE__, "destroy_object_names_array");
    }
    if (obj->property_values) {
        tracked_free(obj->property_values, __FILE__, __LINE__, "destroy_object_values_array");
    }
    if (obj->property_types) {
        tracked_free(obj->property_types, __FILE__, __LINE__, "destroy_object_types_array");
    }
    
    // Free the object itself
    tracked_free(obj, __FILE__, __LINE__, "destroy_object");
}

/**
 * @brief Sets a property on an object with type tracking
 * @param obj The object to modify
 * @param name The property name
 * @param value The property value
 * @param type The property type
 * @return 1 on success, 0 on failure
 */
int object_set_property_typed(MycoObject* obj, const char* name, void* value, PropertyType type) {
    if (!obj || !name) return 0;
    
    // Check if property already exists
    for (int i = 0; i < obj->property_count; i++) {
        if (obj->property_names[i] && strcmp(obj->property_names[i], name) == 0) {
            // Update existing property
            obj->property_values[i] = value;
            obj->property_types[i] = type;
            return 1;
        }
    }
    
    // Expand capacity if needed
    if (obj->property_count >= obj->capacity) {
        int new_capacity = obj->capacity * 2;
        char** new_names = (char**)tracked_realloc(obj->property_names, new_capacity * sizeof(char*), __FILE__, __LINE__, "object_set_property_names");
        if (!new_names) return 0;
        
        void** new_values = (void**)tracked_realloc(obj->property_values, new_capacity * sizeof(void*), __FILE__, __LINE__, "object_set_property_values");
        if (!new_values) {
            tracked_free(new_names, __FILE__, __LINE__, "object_set_property_values_fail");
            return 0;
        }
        
        PropertyType* new_types = (PropertyType*)tracked_realloc(obj->property_types, new_capacity * sizeof(PropertyType), __FILE__, __LINE__, "object_set_property_types");
        if (!new_types) {
            tracked_free(new_values, __FILE__, __LINE__, "object_set_property_types_fail");
            tracked_free(new_names, __FILE__, __LINE__, "object_set_property_types_fail");
            return 0;
        }
        
        obj->property_names = new_names;
        obj->property_values = new_values;
        obj->property_types = new_types;
        
        // Initialize new slots to NULL
        for (int i = obj->capacity; i < new_capacity; i++) {
            obj->property_names[i] = NULL;
            obj->property_values[i] = NULL;
            obj->property_types[i] = PROP_TYPE_NUMBER; // Default type
        }
        
        obj->capacity = new_capacity;
    }
    
    // Add new property
    obj->property_names[obj->property_count] = tracked_strdup(name, __FILE__, __LINE__, "eval");
    obj->property_values[obj->property_count] = value;
    obj->property_types[obj->property_count] = type;
    obj->property_count++;
    
    return 1;
}

/**
 * @brief Sets a property on an object (legacy function, defaults to number type)
 * @param obj The object to modify
 * @param name The property name
 * @param value The property value
 * @return 1 on success, 0 on failure
 */
int object_set_property(MycoObject* obj, const char* name, void* value) {
    // Default to number type for backward compatibility
    return object_set_property_typed(obj, name, value, PROP_TYPE_NUMBER);
}

/**
 * @brief Gets the type of a property from an object
 * @param obj The object to access
 * @param name The property name
 * @return The property type, or PROP_TYPE_NUMBER if not found
 */
PropertyType object_get_property_type(MycoObject* obj, const char* name) {
    if (!obj || !name) return PROP_TYPE_NUMBER;
    
    for (int i = 0; i < obj->property_count; i++) {
        if (obj->property_names[i] && strcmp(obj->property_names[i], name) == 0) {
            return obj->property_types[i];
        }
    }
    
    return PROP_TYPE_NUMBER; // Default if not found
}

/**
 * @brief Helper function to recursively evaluate chained property access for printing
 * @param ast The AST node to evaluate (could be AST_EXPR or AST_DOT)
 * @return Pointer to the final property value, or NULL if not found
 */
static void* evaluate_chained_property_for_print(ASTNode* ast, PropertyType* out_type) {
    if (!ast || !out_type) return NULL;
    
    if (ast->type == AST_EXPR && ast->text) {
        // Base case: simple identifier, get the object
        MycoObject* obj = get_object_value(ast->text);
        if (obj) {
            *out_type = PROP_TYPE_OBJECT;
            return obj;
        }
        return NULL;
    } else if (ast->type == AST_DOT && ast->child_count >= 2) {
        // Recursive case: evaluate left side, then get property from right side
        PropertyType left_type;
        void* left_value = evaluate_chained_property_for_print(&ast->children[0], &left_type);
        
        if (!left_value || left_type != PROP_TYPE_OBJECT) {
            return NULL;
        }
        
        // Get property name from right side
        if (ast->children[1].type == AST_EXPR && ast->children[1].text) {
            MycoObject* obj = (MycoObject*)left_value;
            const char* prop_name = ast->children[1].text;
            
            // Get property value and type
            void* prop_value = object_get_property(obj, prop_name);
            *out_type = object_get_property_type(obj, prop_name);
            
            return prop_value;
        }
    }
    
    return NULL;
}

/**
 * @brief Helper function to print a property value based on its type
 * @param prop_value The property value to print
 * @param prop_type The type of the property
 */
static void print_property_value(void* prop_value, PropertyType prop_type) {
    if (!prop_value) {
        printf("0");
        return;
    }
    
    switch (prop_type) {
        case PROP_TYPE_STRING: {
            char* str_value = (char*)prop_value;
            printf("%s", str_value);
            break;
        }
        case PROP_TYPE_NUMBER: {
            printf("%lld", (long long)prop_value);
            break;
        }
        case PROP_TYPE_OBJECT: {
            MycoObject* obj = (MycoObject*)prop_value;
            printf("{");
            for (int i = 0; i < obj->property_count; i++) {
                if (i > 0) printf(", ");
                printf("%s: ", obj->property_names[i]);
                
                // Recursively print nested property values
                void* nested_value = obj->property_values[i];
                PropertyType nested_type = obj->property_types[i];
                print_property_value(nested_value, nested_type);
            }
            printf("}");
            break;
        }
    }
}

/**
 * @brief Gets a property from an object
 * @param obj The object to access
 * @param name The property name
 * @return Pointer to the property value, or NULL if not found
 */
void* object_get_property(MycoObject* obj, const char* name) {
    if (!obj || !name) return NULL;
    
    for (int i = 0; i < obj->property_count; i++) {
        if (obj->property_names[i] && strcmp(obj->property_names[i], name) == 0) {
            return obj->property_values[i];
        }
    }
    return NULL;
}

/**
 * @brief Checks if an object has a specific property
 * @param obj The object to check
 * @param name The property name
 * @return 1 if property exists, 0 otherwise
 */
int object_has_property(MycoObject* obj, const char* name) {
    if (!obj || !name) return 0;
    
    for (int i = 0; i < obj->property_count; i++) {
        if (obj->property_names[i] && strcmp(obj->property_names[i], name) == 0) {
            return 1;
        }
    }
    return 0;
}

/**
 * @brief Cleans up all arrays in the variable environment
 */
void cleanup_array_env() {
    if (var_env && var_env_size > 0) {
        for (int i = 0; i < var_env_size; i++) {
            if (var_env[i].name && var_env[i].type == VAR_TYPE_ARRAY && var_env[i].array_value) {
                destroy_array(var_env[i].array_value);
                var_env[i].array_value = NULL;
            }
        }
    }
}

/**
 * @brief Cleans up all objects in the variable environment
 */
void cleanup_object_env() {
    if (var_env && var_env_size > 0) {
        for (int i = 0; i < var_env_size; i++) {
            if (var_env[i].name && var_env[i].type == VAR_TYPE_OBJECT && var_env[i].object_value) {
                destroy_object(var_env[i].object_value);
                var_env[i].object_value = NULL;
            }
        }
    }
}

/**
 * @brief Gets an object variable from the environment
 * @param name The variable name
 * @return Pointer to the object, or NULL if not found
 */
MycoObject* get_object_value(const char* name) {
    // Search from the end (most recent variables first) to prioritize function parameters
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (var_env[i].name && strcmp(var_env[i].name, name) == 0) {
            if (var_env[i].type == VAR_TYPE_OBJECT) {
                return var_env[i].object_value;
            }
            return NULL;
        }
    }
    return NULL;
}

/**
 * @brief Sets an object variable in the environment
 * @param name The variable name
 * @param obj The object to store
 */
void set_object_value(const char* name, MycoObject* obj) {
    if (!name || !obj) return;
    
    // Check if variable already exists
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (strcmp(var_env[i].name, name) == 0) {
            // Update existing variable
            if (var_env[i].type == VAR_TYPE_OBJECT && var_env[i].object_value) {
                destroy_object(var_env[i].object_value);
            }
            var_env[i].type = VAR_TYPE_OBJECT;
            var_env[i].object_value = obj;
            var_env[i].number_value = 0;
            var_env[i].string_value = NULL;
            var_env[i].array_value = NULL;
            return;
        }
    }
    
    // Expand capacity if needed
    if (var_env_size >= var_env_capacity) {
        int new_capacity = var_env_capacity ? var_env_capacity * 2 : 8;
        VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_object");
        if (!new_env) {
            // Handle realloc failure
            return;
        }
        var_env = new_env;
        var_env_capacity = new_capacity;
    }
    
    // Add new variable
    var_env[var_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    if (var_env[var_env_size].name) {
        var_env[var_env_size].type = VAR_TYPE_OBJECT;
        var_env[var_env_size].object_value = obj;
        var_env[var_env_size].number_value = 0;
        var_env[var_env_size].string_value = NULL;
        var_env[var_env_size].array_value = NULL;
    var_env_size++;
    }
}

// Cleanup function for function environment
static void cleanup_func_env() {
    if (functions && functions_size > 0) {
        for (int i = 0; i < functions_size; i++) {
            if (functions[i].name) {
                tracked_free(functions[i].name, __FILE__, __LINE__, "cleanup_func_env");
                functions[i].name = NULL;
            }
        }
        tracked_free(functions, __FILE__, __LINE__, "cleanup_func_env");
        functions = NULL;
        functions_size = 0;
        functions_cap = 0;
    }
}

// Cleanup function for module environment
static void cleanup_module_env() {
    if (modules && modules_size > 0) {
        for (int i = 0; i < modules_size; i++) {
            if (modules[i].alias) {
                tracked_free(modules[i].alias, __FILE__, __LINE__, "cleanup_module_env");
                modules[i].alias = NULL;
            }
            // Don't free module_ast here as it's owned by the parser
            modules[i].module_ast = NULL;
        }
        tracked_free(modules, __FILE__, __LINE__, "cleanup_module_env");
        modules = NULL;
        modules_size = 0;
        modules_cap = 0;
    }
}

// Master cleanup function
void cleanup_all_environments() {

    
    cleanup_str_env();
    cleanup_var_env();
    cleanup_array_env();
    cleanup_object_env();
    cleanup_func_env();
    cleanup_module_env();
    

}

// Helper: is this integer an error code of our 0xMY[SEV][MOD][ERR] scheme?
static int is_error_code(int value) {
    int sev = (value >> 16) & 0xFF;
    return sev == 0x02 || sev == 0x0F; // ERROR or FATAL
}

// Helper function to format error value for printing
static void format_error_value(int value, char* buffer, size_t size) {
    if (is_error_code(value)) {
        const char* desc = get_error_description(value);
        char lower_desc[256];
        strncpy(lower_desc, desc, sizeof(lower_desc) - 1);
        lower_desc[0] = tolower(lower_desc[0]);
        snprintf(buffer, size, "%s%s%s", RED, lower_desc, RESET);
    } else {
        snprintf(buffer, size, "%d", value);
    }
}

static ASTNode* load_and_parse_module(const char* path) {
    char full[2048];
    compute_full_path(path, full, sizeof(full));
    FILE* f = fopen(full, "r");
    if (!f) return NULL;
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    fseek(f, 0, SEEK_SET);
    char* buf = (char*)tracked_malloc(sz + 1, __FILE__, __LINE__, "load_module_file");
    if (!buf) { fclose(f); return NULL; }
    fread(buf, 1, sz, f); buf[sz] = '\0'; fclose(f);
    Token* toks = lexer_tokenize(buf);
    tracked_free(buf, __FILE__, __LINE__, "load_module_file");
    if (!toks) return NULL;
    ASTNode* mod = parser_parse(toks);
    lexer_free_tokens(toks);
    return mod;
}

static void register_module(const char* alias, ASTNode* ast) {
    if (!alias) return;
    
    // Check if module already exists
    for (int i = 0; i < modules_size; i++) {
        if (strcmp(modules[i].alias, alias) == 0) {
            // Module already exists, update it
            modules[i].module_ast = ast;
            return;
        }
    }
    
    // Expand capacity if needed
    if (modules_size >= modules_cap) {
        int new_cap = modules_cap ? modules_cap * 2 : 4;
        ModuleEntry* new_modules = (ModuleEntry*)tracked_realloc(modules, new_cap * sizeof(ModuleEntry), __FILE__, __LINE__, "expand_modules");
        if (!new_modules) {
            // Handle realloc failure
            return;
        }
        modules = new_modules;
        modules_cap = new_cap;
    }
    
    // Add new module
    modules[modules_size].alias = tracked_strdup(alias, __FILE__, __LINE__, "eval");
    if (modules[modules_size].alias) {
        modules[modules_size].module_ast = ast;
        modules_size++;
        
        // Register all functions and constants from the module with module prefix
        if (ast) {
            for (int i = 0; i < ast->child_count; i++) {
                ASTNode* n = &ast->children[i];
                if (n->type == AST_FUNC && n->text) {
                    // Register function with module prefix for namespaced access
                    char prefixed_name[256];
                    snprintf(prefixed_name, sizeof(prefixed_name), "%s.%s", alias, n->text);
                    register_function(prefixed_name, n);
                    
                    // Also register without prefix for backward compatibility
                    register_function(n->text, n);
                } else if (n->type == AST_LET && n->child_count >= 2) {
                    // Register constants (variables) with module prefix
                    const char* const_name = n->children[0].text;
                    if (const_name) {
                        // For constants, we need to evaluate them and store with module prefix
                        // This is a simplified approach - in a full implementation you'd want
                        // to store the AST and evaluate on demand
                        char prefixed_name[256];
                        snprintf(prefixed_name, sizeof(prefixed_name), "%s.%s", alias, const_name);
                        
                        // Evaluate the constant value and store it
                        if (n->children[1].type == AST_EXPR && n->children[1].text) {
                            if (is_string_literal(n->children[1].text)) {
                                // String constant - extract the value between quotes
                                size_t len = strlen(n->children[1].text);
                                if (len >= 2) {
                                    char* value = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "module_string_constant");
                                    if (value) {
                                        strncpy(value, n->children[1].text + 1, len - 2);
                                        value[len - 2] = '\0';
                                        set_str_value(prefixed_name, value);
                                        // String constant registered successfully
                                        tracked_free(value, __FILE__, __LINE__, "module_string_constant");
                                    }
                                }
                            } else {
                                // Numeric constant - evaluate it
                                long long value = eval_expression(&n->children[1]);
                                set_var_value(prefixed_name, value);
                                // Numeric constant registered successfully
                            }
                        }
                    }
                }
            }
        }
    }
}

static ASTNode* find_function_in_module(ASTNode* mod, const char* name) {
    if (!mod) return NULL;
    for (int i = 0; i < mod->child_count; i++) {
        ASTNode* n = &mod->children[i];
        if (n->type == AST_FUNC && n->text && strcmp(n->text, name) == 0) return n;
    }
    return NULL;
}

static ASTNode* resolve_module(const char* alias) {
    for (int i = 0; i < modules_size; i++) {
        if (strcmp(modules[i].alias, alias) == 0) return modules[i].module_ast;
    }
    return NULL;
}

// Find a function in a specific module by module name and function name
static ASTNode* find_function_with_module_prefix(const char* module_name, const char* function_name) {
    ASTNode* mod = resolve_module(module_name);
    if (mod) {
        return find_function_in_module(mod, function_name);
    }
    return NULL;
}

// Find a function in any loaded module (for backward compatibility)
static ASTNode* find_function_in_any_module(const char* name) {
    for (int i = 0; i < modules_size; i++) {
        ASTNode* fn = find_function_in_module(modules[i].module_ast, name);
        if (fn) return fn;
    }
    return NULL;
}

// Interpret a user-defined function call: evaluate args, bind params, execute body, capture return
static long long eval_user_function_call(ASTNode* fn, ASTNode* args_node) {
    if (!fn) return 0;
    // find body index
    int body_index = -1;
    for (int i = 0; i < fn->child_count; i++) {
        if (fn->children[i].type == AST_BLOCK) { body_index = i; break; }
    }
    if (body_index < 0) return 0;
    // collect parameter names (AST_EXPR before body, excluding type markers like 'int' and 'string')
    int param_indices[16]; int param_count = 0;
    for (int i = 0; i < body_index && param_count < 16; i++) {
        if (fn->children[i].type == AST_EXPR && fn->children[i].text && 
            strcmp(fn->children[i].text, "int") != 0 && 
            strcmp(fn->children[i].text, "string") != 0) {
            param_indices[param_count++] = i;
        }
    }
    // evaluate arguments
    long long argvals[16]; int argn = 0;
    
    // Find the arguments container (should be the second child)
    if (args_node && args_node->child_count >= 2) {
        ASTNode* args_container = &args_node->children[1]; // Second child should be args container
        if (args_container->text && strcmp(args_container->text, "args") == 0) {
            argn = args_container->child_count;
            for (int i = 0; i < argn && i < 16; i++) {
                argvals[i] = eval_expression(&args_container->children[i]);
                if (error_occurred) return 0;
            }
        } else {
            argn = args_node->child_count;
            for (int i = 0; i < argn && i < 16; i++) {
                argvals[i] = eval_expression(&args_node->children[i]);
                if (error_occurred) return 0;
            }
        }
    } else {
        argn = 0;
    }
    // Create new scope for function call
    push_scope();
    
    // bind params
    for (int i = 0; i < param_count && i < argn; i++) {
        const char* pname = fn->children[param_indices[i]].text;
        
        // Force parameter binding by always adding as new variable (don't update existing)
        // This ensures function parameters override global variables
        if (var_env_size >= var_env_capacity) {
            int new_capacity = var_env_capacity ? var_env_capacity * 2 : 8;
            VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_function");
            if (!new_env) {
                fprintf(stderr, "Error: Failed to expand variable environment\n");
                        return 0;
                    }
            var_env = new_env;
            var_env_capacity = new_capacity;
        }
        
        // Always add as new variable to ensure parameter binding works
        var_env[var_env_size].name = tracked_strdup(pname, __FILE__, __LINE__, "eval");
        if (var_env[var_env_size].name) {
            // Check if parameter has explicit type annotation
            int param_index = param_indices[i];
            int has_type = 0;
            if (param_index < fn->child_count && fn->children[param_index].children && fn->children[param_index].child_count > 0) {
                has_type = 1;
            }
            
            if (has_type) {
                // Parameter has explicit type - use it
                var_env[var_env_size].type = VAR_TYPE_NUMBER;  // For now, default to number
            var_env[var_env_size].number_value = argvals[i];
            } else {
                // Implicit parameter - infer type from argument
                var_env[var_env_size].type = VAR_TYPE_NUMBER;  // Default to number for now
                var_env[var_env_size].number_value = argvals[i];
            }
            
            var_env[var_env_size].array_value = NULL;
            var_env[var_env_size].string_value = NULL;
            var_env[var_env_size].object_value = NULL;
            var_env_size++;
        }
        
        // Also bind as string for compatibility
        char temp_str[64];
        snprintf(temp_str, sizeof(temp_str), "%lld", argvals[i]);
        set_str_value(pname, temp_str);
    }
    // execute

    

    
    int saved_return_flag = return_flag; long long saved_return_value = return_value;
    return_flag = 0; return_value = 0;
    
    eval_evaluate(&fn->children[body_index]);
    
    long long rv = return_value;
    // restore return state
    return_flag = saved_return_flag; return_value = saved_return_value;
    
    // Clean up function scope
    pop_scope();
    
    return rv;
}

long long eval_expression(ASTNode* ast) {
    if (!ast) {
                        return 0;
                    }
    

    
    if (error_occurred) {
        return 0;
    }

    // Update current line for expression-level errors
    if (ast->line > 0) {
        current_line = ast->line;
    }


    
    // Handle string literals first
    if (ast->text && is_string_literal(ast->text)) {
        // Extract the string value (remove quotes)
        size_t len = strlen(ast->text);
        if (len >= 2) {
            char* value = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "eval_string_constant");
            if (value) {
                strncpy(value, ast->text + 1, len - 2);
                value[len - 2] = '\0';
                
                // Store in a temporary variable for parameter binding
                char temp_var_name[64];
                snprintf(temp_var_name, sizeof(temp_var_name), "__temp_str_lit_%p", (void*)ast);
                set_str_value(temp_var_name, value);
                tracked_free(value, __FILE__, __LINE__, "eval_string_constant");
            }
        }
        return 1; // Return 1 to indicate this is a string
    }

    // Handle numeric literals (integers and floats)
    if (ast->text && ast->child_count == 0) {
        char* endptr;
        
                // Check if this is a float (contains decimal point)
        if (strchr(ast->text, '.') != NULL) {
            double float_val = strtod(ast->text, &endptr);
            if (*endptr == '\0') {
                // Return scaled float for compatibility with integer return system
                return (long long)(float_val * 1000000);
            }
        } else {
            // Handle integer
        long long num = strtoll(ast->text, &endptr, 10);
        if (*endptr == '\0') {
            return num; // Return the numeric value
            }
        }
    }

    // Handle operators
    if (ast->text && (strcmp(ast->text, "+") == 0 || strcmp(ast->text, "-") == 0 ||
        strcmp(ast->text, "*") == 0 || strcmp(ast->text, "/") == 0 ||
        strcmp(ast->text, "%") == 0 || strcmp(ast->text, "==") == 0 ||
        strcmp(ast->text, "!=") == 0 || strcmp(ast->text, "<") == 0 ||
        strcmp(ast->text, ">") == 0 || strcmp(ast->text, "<=") == 0 ||
        strcmp(ast->text, ">=") == 0 || strcmp(ast->text, "and") == 0 ||
        strcmp(ast->text, "or") == 0)) {
        
        // Handle numeric operations
        if (ast->child_count >= 2) {
            long long left = eval_expression(&ast->children[0]);
            if (error_occurred) return 0;
            long long right = eval_expression(&ast->children[1]);
            if (error_occurred) return 0;
            
            long long result = 0;
            if (strcmp(ast->text, "+") == 0) {
                // Check if either operand is a string for concatenation
                if (left == -1 || right == -1 || left == 1 || right == 1) {
                    // String concatenation
                    char* left_str = NULL;
                    char* right_str = NULL;
                    
                    // Get left string value
                    if (left == -1) {
                        // Left operand is a string variable or previous concatenation result
                        if (last_concat_result) {
                            // Use the result of a previous concatenation
                            left_str = tracked_strdup(last_concat_result, __FILE__, __LINE__, "eval");
                        } else if (ast->children[0].type == AST_EXPR && ast->children[0].text) {
                            // Get from string variable
                            left_str = (char*)get_str_value(ast->children[0].text);
                        }
                    } else if (left == 1) {
                        // Left operand is a string literal - get its value from the AST
                        if (ast->children[0].type == AST_EXPR && ast->children[0].text && is_string_literal(ast->children[0].text)) {
                            size_t len = strlen(ast->children[0].text);
                            if (len >= 2) {
                                left_str = tracked_strdup(ast->children[0].text + 1, __FILE__, __LINE__, "eval");
                                left_str[len - 2] = '\0';
                            }
                        }
                    } else {
                        // Left operand is a number - convert to string
                        char temp_str[64];
                        snprintf(temp_str, sizeof(temp_str), "%lld", left);
                        left_str = tracked_strdup(temp_str, __FILE__, __LINE__, "eval");
                    }
                    
                    // Get right string value
                    if (right == -1) {
                        // Right operand is a string variable - get its name from the AST
                        if (ast->children[1].type == AST_EXPR && ast->children[1].text) {
                            right_str = (char*)get_str_value(ast->children[1].text);
                        }
                    } else if (right == 1) {
                        // Right operand is a string literal - get its value from the AST
                        if (ast->children[1].type == AST_EXPR && ast->children[1].text && is_string_literal(ast->children[1].text)) {
                            size_t len = strlen(ast->children[1].text);
                            if (len >= 2) {
                                right_str = tracked_strdup(ast->children[1].text + 1, __FILE__, __LINE__, "eval");
                                right_str[len - 2] = '\0';
                            }
                        }
                    } else {
                        // Right operand is a number - convert to string
                        char temp_str[64];
                        snprintf(temp_str, sizeof(temp_str), "%lld", right);
                        right_str = tracked_strdup(temp_str, __FILE__, __LINE__, "eval");
                    }
                    
                    // Concatenate strings
                    if (left_str && right_str) {
                        size_t total_len = strlen(left_str) + strlen(right_str) + 1;
                        char* result_str = (char*)tracked_malloc(total_len, __FILE__, __LINE__, "eval_concat_result");
                        if (result_str) {
                            strcpy(result_str, left_str);
                            strcat(result_str, right_str);
                            
                            // Store the concatenated string in a temporary variable
                            char temp_var_name[64];
                            snprintf(temp_var_name, sizeof(temp_var_name), "__temp_concat_%p", (void*)ast);
                            set_str_value(temp_var_name, result_str);
                            
                            // Also store it in the global variable for easier access
                            if (last_concat_result) {
                                free(last_concat_result);
                            }
                            last_concat_result = tracked_strdup(result_str, __FILE__, __LINE__, "eval");
                            
                            // Clean up
                            if (left != -1 && left_str) free(left_str);
                            if (right != -1 && right_str) free(right_str);
                            free(result_str);
                            
                            // Return special value to indicate this is a concatenated string
                            return -1;
                        }
                    }
                    
                    // Clean up on failure
                    if (left != -1 && left_str) free(left_str);
                    if (right != -1 && right_str) free(right_str);
                    
                    // Fall back to numeric addition
                    if (left == -1) {
                        // Left operand is a string - this shouldn't happen in normal flow
                        // but if it does, we need to handle it properly
                        return -1; // Return string indicator
                    } else if (right == -1) {
                        // Right operand is a string - this shouldn't happen in normal flow
                        // but if it does, we need to handle it properly
                        return -1; // Return string indicator
                    } else {
                        result = left + right;
                    }
                } else {
                    // Check if either operand is a float for addition
                    int left_is_float = 0, right_is_float = 0;
                    double left_float = 0.0, right_float = 0.0;
                    
                    // Check left operand
                    if (ast->children[0].text && strchr(ast->children[0].text, '.') != NULL) {
                        left_is_float = 1;
                        left_float = strtod(ast->children[0].text, NULL);
                    } else if (ast->children[0].text) {
                        // Check if it's a float variable
                        for (int i = var_env_size - 1; i >= 0; i--) {
                            if (var_env[i].name && strcmp(var_env[i].name, ast->children[0].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                                left_is_float = 1;
                                left_float = var_env[i].float_value;
                                break;
                            }
                        }
                        if (!left_is_float) left_float = (double)left;
                    } else {
                        left_float = (double)left;
                    }
                    
                    // Check right operand
                    if (ast->children[1].text && strchr(ast->children[1].text, '.') != NULL) {
                        right_is_float = 1;
                        right_float = strtod(ast->children[1].text, NULL);
                    } else if (ast->children[1].text) {
                        // Check if it's a float variable
                        for (int i = var_env_size - 1; i >= 0; i--) {
                            if (var_env[i].name && strcmp(var_env[i].name, ast->children[1].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                                right_is_float = 1;
                                right_float = var_env[i].float_value;
                                break;
                            }
                        }
                        if (!right_is_float) right_float = (double)right;
                    } else {
                        right_float = (double)right;
                    }
                    
                    if (left_is_float || right_is_float) {
                        // Float arithmetic
                        double float_result = left_float + right_float;
                        result = (long long)(float_result * 1000000);
                        last_result_is_float = 1;
                    } else {
                        // Regular numeric addition
                        result = left + right;
                        last_result_is_float = 0;
                    }
                }
            } else if (strcmp(ast->text, "-") == 0) {
                // Check if either operand is a float
                int left_is_float = 0, right_is_float = 0;
                double left_float = 0.0, right_float = 0.0;
                
                // Check left operand
                if (ast->children[0].text && strchr(ast->children[0].text, '.') != NULL) {
                    left_is_float = 1;
                    left_float = strtod(ast->children[0].text, NULL);
                } else if (ast->children[0].text) {
                    // Check if it's a float variable
                    for (int i = var_env_size - 1; i >= 0; i--) {
                        if (var_env[i].name && strcmp(var_env[i].name, ast->children[0].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                            left_is_float = 1;
                            left_float = var_env[i].float_value;
                            break;
                        }
                    }
                    if (!left_is_float) left_float = (double)left;
                } else {
                    left_float = (double)left;
                }
                
                // Check right operand
                if (ast->children[1].text && strchr(ast->children[1].text, '.') != NULL) {
                    right_is_float = 1;
                    right_float = strtod(ast->children[1].text, NULL);
                } else if (ast->children[1].text) {
                    // Check if it's a float variable
                    for (int i = var_env_size - 1; i >= 0; i--) {
                        if (var_env[i].name && strcmp(var_env[i].name, ast->children[1].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                            right_is_float = 1;
                            right_float = var_env[i].float_value;
                            break;
                        }
                    }
                    if (!right_is_float) right_float = (double)right;
                } else {
                    right_float = (double)right;
                }
                
                if (left_is_float || right_is_float) {
                    // Float arithmetic
                    double float_result = left_float - right_float;
                    result = (long long)(float_result * 1000000);
                    last_result_is_float = 1;
                } else {
                    // Integer arithmetic
                    result = left - right;
                    last_result_is_float = 0;
                }
            }
            else if (strcmp(ast->text, "*") == 0) {
                // Check if either operand is a float (same logic as subtraction)
                int left_is_float = 0, right_is_float = 0;
                double left_float = 0.0, right_float = 0.0;
                
                // Check left operand
                if (ast->children[0].text && strchr(ast->children[0].text, '.') != NULL) {
                    left_is_float = 1;
                    left_float = strtod(ast->children[0].text, NULL);
                } else if (ast->children[0].text) {
                    for (int i = var_env_size - 1; i >= 0; i--) {
                        if (var_env[i].name && strcmp(var_env[i].name, ast->children[0].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                            left_is_float = 1;
                            left_float = var_env[i].float_value;
                            break;
                        }
                    }
                    if (!left_is_float) left_float = (double)left;
                } else {
                    left_float = (double)left;
                }
                
                // Check right operand
                if (ast->children[1].text && strchr(ast->children[1].text, '.') != NULL) {
                    right_is_float = 1;
                    right_float = strtod(ast->children[1].text, NULL);
                } else if (ast->children[1].text) {
                    for (int i = var_env_size - 1; i >= 0; i--) {
                        if (var_env[i].name && strcmp(var_env[i].name, ast->children[1].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                            right_is_float = 1;
                            right_float = var_env[i].float_value;
                            break;
                        }
                    }
                    if (!right_is_float) right_float = (double)right;
                } else {
                    right_float = (double)right;
                }
                
                if (left_is_float || right_is_float) {
                    // Float arithmetic
                    double float_result = left_float * right_float;
                    result = (long long)(float_result * 1000000);
                    last_result_is_float = 1;
                } else {
                    // Integer arithmetic
                    result = left * right;
                    last_result_is_float = 0;
                }
            }
            else if (strcmp(ast->text, "/") == 0) {
                if (right == 0) { set_error(ERROR_DIVISION_BY_ZERO); return 0; }
                
                // Check if either operand is a float (same logic as above)
                int left_is_float = 0, right_is_float = 0;
                double left_float = 0.0, right_float = 0.0;
                
                // Check left operand
                if (ast->children[0].text && strchr(ast->children[0].text, '.') != NULL) {
                    left_is_float = 1;
                    left_float = strtod(ast->children[0].text, NULL);
                } else if (ast->children[0].text) {
                    for (int i = var_env_size - 1; i >= 0; i--) {
                        if (var_env[i].name && strcmp(var_env[i].name, ast->children[0].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                            left_is_float = 1;
                            left_float = var_env[i].float_value;
                            break;
                        }
                    }
                    if (!left_is_float) left_float = (double)left;
                } else {
                    left_float = (double)left;
                }
                
                // Check right operand
                if (ast->children[1].text && strchr(ast->children[1].text, '.') != NULL) {
                    right_is_float = 1;
                    right_float = strtod(ast->children[1].text, NULL);
                } else if (ast->children[1].text) {
                    for (int i = var_env_size - 1; i >= 0; i--) {
                        if (var_env[i].name && strcmp(var_env[i].name, ast->children[1].text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                            right_is_float = 1;
                            right_float = var_env[i].float_value;
                            break;
                        }
                    }
                    if (!right_is_float) right_float = (double)right;
                } else {
                    right_float = (double)right;
                }
                
                if (right_float == 0.0) { set_error(ERROR_DIVISION_BY_ZERO); return 0; }
                
                if (left_is_float || right_is_float) {
                    // Float arithmetic
                    double float_result = left_float / right_float;
                    result = (long long)(float_result * 1000000);
                    last_result_is_float = 1;
                } else {
                    // Integer arithmetic
                    result = left / right;
                    last_result_is_float = 0;
                }
            }
            else if (strcmp(ast->text, "%") == 0) {
                if (right == 0) { set_error(ERROR_MODULO_BY_ZERO); return 0; }
                result = left % right;
            }
            else if (strcmp(ast->text, "==") == 0) result = left == right;
            else if (strcmp(ast->text, "!=") == 0) result = left != right;
            else if (strcmp(ast->text, "<") == 0) result = left < right;
            else if (strcmp(ast->text, ">") == 0) result = left > right;
            else if (strcmp(ast->text, "<=") == 0) result = left <= right;
            else if (strcmp(ast->text, ">=") == 0) result = left >= right;
            else if (strcmp(ast->text, "and") == 0) result = left && right;
            else if (strcmp(ast->text, "or") == 0) result = left || right;
            
            return result;
        }
    }

    // Handle array access
    if (ast->type == AST_ARRAY_ACCESS) {
        if (ast->child_count < 2) {
            fprintf(stderr, "Error: Invalid array access structure\n");
            return 0;
        }
        
        // Get the array name from the first child
        char* array_name = NULL;
        if (ast->children[0].type == AST_EXPR && ast->children[0].text) {
            array_name = ast->children[0].text;
        } else {
            fprintf(stderr, "Error: Invalid array expression at line %d\n", ast->line);
            return 0;
        }
        
        // Get the array variable
        MycoArray* array = get_array_value(array_name);
        if (!array) {
            fprintf(stderr, "Error: Array '%s' not found at line %d\n", array_name, ast->line);
            return 0;
        }
        
        // Evaluate the index expression
        long long index = eval_expression(&ast->children[1]);
        if (index < 0 || index >= array->size) {
            fprintf(stderr, "Error: Array index %lld out of bounds [0, %d] at line %d\n", 
                    index, array->size - 1, ast->line);
            return 0;
        }
        
        // Get the element value
        void* element = array_get(array, index);
        if (!element) {
            fprintf(stderr, "Error: Failed to access array element at line %d\n", ast->line);
            return 0;
        }
        
        if (array->is_string_array) {
            return 0; // String arrays return 0 for now
        } else {
            return *(long long*)element;
        }
    }
    
    // Handle object property access
    if (ast->type == AST_DOT) {

        if (ast->child_count < 2) {
            fprintf(stderr, "Error: Invalid object property access structure\n");
            return 0;
        }
        
        // Check if this is a library constant access (e.g., m.PI, m.E) before treating as object access
        if (ast->children[0].type == AST_EXPR && ast->children[0].text &&
            ast->children[1].type == AST_EXPR && ast->children[1].text) {
            
            const char* alias = ast->children[0].text;
            const char* constant_name = ast->children[1].text;
            const char* actual_library = get_library_alias(alias);
            
            if (actual_library) {
                // This is a library alias - handle constants
                if (strcmp(actual_library, "math") == 0) {
                    if (strcmp(constant_name, "PI") == 0) {
                        return (long long)(3.141592653589793 * 1000000);
                    } else if (strcmp(constant_name, "E") == 0) {
                        return (long long)(2.718281828459045 * 1000000);
                    } else if (strcmp(constant_name, "INF") == 0) {
                        return 999999999;
                    } else if (strcmp(constant_name, "NAN") == 0) {
                        return -999999999;
                    }
                }
                // If not a recognized constant, continue to object access handling
                // This allows for potential library function calls later
            }
        }
        
        // Handle nested property access recursively
        // For obj.user.name, we need to resolve obj.user first, then get .name
        
        // First, evaluate the left side (could be an identifier or another dot expression)
        long long left_value = 0;
        if (ast->children[0].type == AST_DOT) {
            // This is a nested dot expression like obj.user.name
            // Recursively evaluate the left side first
            left_value = eval_expression(&ast->children[0]);
        } else if (ast->children[0].type == AST_EXPR && ast->children[0].text) {
            // This is a simple identifier like obj in obj.prop
            // Get the object variable
            MycoObject* obj = get_object_value(ast->children[0].text);
            if (!obj) {
                fprintf(stderr, "Error: Object '%s' not found at line %d\n", ast->children[0].text, ast->line);
                return 0;
            }
            // For now, we'll use the object pointer as the left value
            // This is a temporary solution - we need to handle object references properly
            left_value = (long long)obj;
        } else {
            fprintf(stderr, "Error: Invalid object expression at line %d\n", ast->line);
            return 0;
        }
        
        // Get the property name from the second child
        char* prop_name = NULL;
        if (ast->children[1].type == AST_EXPR && ast->children[1].text) {
            prop_name = ast->children[1].text;
        } else {
            fprintf(stderr, "Error: Invalid property name at line %d\n", ast->line);
            return 0;
        }
        
        // Handle object reference from recursive evaluation
        MycoObject* obj = NULL;
        if (left_value == -10) {
            // Object reference was stored globally
            obj = __chained_object_ref;
            if (!obj) {
                fprintf(stderr, "Error: Lost object reference in chained access at line %d\n", ast->line);
                return 0;
            }
        } else {
            // Traditional approach - cast the value back to object pointer
            obj = (MycoObject*)left_value;
        if (!obj) {
            fprintf(stderr, "Error: Invalid object reference at line %d\n", ast->line);
            return 0;
            }
        }
        
        // Get the property value
        void* prop_value = object_get_property(obj, prop_name);
        if (!prop_value) {
            fprintf(stderr, "Error: Property '%s' not found in object at line %d\n", prop_name, ast->line);
            return 0;
        }
        
        // Check if this is a method property
        if (prop_value && strcmp((char*)prop_value, "method") == 0) {
            // This is a method - execute it
            
            // Execute different methods based on the method name
            if (strcmp(prop_name, "add") == 0) {
                // Add method - return the sum of object properties
                return 42; // Placeholder return value
            } else if (strcmp(prop_name, "getInfo") == 0) {
                // GetInfo method - return object information
                return 100; // Placeholder return value
            } else {
                // Generic method
                return 1; // Return success
            }
        }
        
        // Check if the property value is an object for chained access
        PropertyType prop_type = object_get_property_type(obj, prop_name);
        if (prop_type == PROP_TYPE_OBJECT && prop_value) {
            MycoObject* nested_obj = (MycoObject*)prop_value;
            // This is a nested object - store for chained access
            __chained_object_ref = nested_obj;

            return -10;  // Special code: object reference stored globally
        }
        
        // For non-object values (numbers, strings), return as-is

        return (long long)prop_value;
    }
    
    // Handle object bracket access: obj["key"] or obj[variable]
    if (ast->type == AST_OBJECT_BRACKET_ACCESS) {
        if (ast->child_count < 2) {
            return 0;
        }
        
        // First child is the object expression, second child is the key expression
        ASTNode* obj_expr = &ast->children[0];
        ASTNode* key_expr = &ast->children[1];
        
        // Get the object (assume simple identifier for now)
        MycoObject* obj = NULL;
        if (obj_expr->type == AST_EXPR && obj_expr->text) {
            obj = get_object_value(obj_expr->text);
        }
        
        if (!obj) {
            return 0;
        }
        
        // Evaluate the key expression to get the property name
        const char* prop_name = NULL;
        long long key_result = eval_expression(key_expr);
        
        if (key_result == 1) {
            // This is a string literal - extract the key
            if (key_expr->text && is_string_literal(key_expr->text)) {
                size_t len = strlen(key_expr->text);
                if (len >= 2) {
                    char* temp_key = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                    if (temp_key) {
                        strncpy(temp_key, key_expr->text + 1, len - 2);
                        temp_key[len - 2] = '\0';
                        prop_name = temp_key;
                    }
                }
            }
        } else if (key_result == -1) {
            // This is a string variable - get its value
            if (key_expr->text) {
                prop_name = get_str_value(key_expr->text);
            }
        }
        
        if (!prop_name) {
            return 0;
        }
        
        // Get the property value
        void* prop_value = object_get_property(obj, prop_name);
        if (!prop_value) {
            return 0;
        }
        
        // Determine if it's a string or number
        if ((long long)prop_value > 1000000) {
            // Likely a string pointer
            char* str_value = (char*)prop_value;
            size_t len = strnlen(str_value, 256);
            if (len > 0 && len < 256) {
                int looks_like_string = 1;
                for (size_t i = 0; i < len && i < 10; i++) {
                    if (str_value[i] < 32 || str_value[i] > 126) {
                        looks_like_string = 0;
                        break;
                    }
                }
                if (looks_like_string) {
                    // Simple approach: print the string directly and return special value
                    printf("%s", str_value);
                    return -999; // Special value: already printed, don't process further
                }
            }
        }
        
        // Otherwise, assume it's a number
        return (long long)prop_value;
    }
    
    // Handle function calls (text="call" with children)
    if (ast->text && strcmp(ast->text, "call") == 0 && ast->child_count >= 2) {
        // Get function name from first child
        ASTNode* func_name_node = &ast->children[0];
        char* func_name = func_name_node->text;
        
        // First check for built-in functions
        if (func_name) {
            if (strcmp(func_name, "input") == 0) {
                return call_core_function("input", &ast->children[1]);
            } else if (strcmp(func_name, "print") == 0) {
                return call_core_function("print", &ast->children[1]);
            } else if (strcmp(func_name, "len") == 0) {
                return call_core_function("len", &ast->children[1]);
            } else if (strcmp(func_name, "to_string") == 0) {
                return call_core_function("to_string", &ast->children[1]);
            } else if (strcmp(func_name, "str") == 0) {
                return call_core_function("str", &ast->children[1]);
            }
        }
        
        // Then check for user-defined functions
        if (func_name) {
            ASTNode* user_func = find_function_global(func_name);
            if (user_func) {
                // Call user-defined function
                return eval_user_function_call(user_func, ast);
            }
        }
        
        // Check for lambda functions
        if (func_name) {
            ASTNode* lambda_func = get_lambda_value(func_name);
            if (lambda_func) {
                // Call lambda function
                return execute_lambda(lambda_func, &ast->children[1]);
            }
        }
        
        // Check for library function calls (e.g., math.abs, util.debug)
        if (func_name && strchr(func_name, '.') != NULL) {
            char* dot_pos = strchr(func_name, '.');
            if (dot_pos) {
                char library_name[256];
                char function_name[256];
                
                // Extract library and function names
                size_t lib_len = dot_pos - func_name;
                strncpy(library_name, func_name, lib_len);
                library_name[lib_len] = '\0';
                
                strcpy(function_name, dot_pos + 1);
                
                // Check if this library is imported
                const char* alias = get_library_alias(library_name);
                if (alias) {
                    // For now, just print a message about the library function call
                    printf("Library function call: %s.%s() (imported as %s)\n", library_name, function_name, alias);
                    return 0; // Placeholder return
                } else {
                    fprintf(stderr, "Error: Library '%s' not imported. Use 'use %s as <alias>;' first\n", library_name, library_name);
                    return 0;
                }
            }
        }
        
        // Check for dot expression function calls and constants (e.g., m.abs, m.PI, u.debug)
        if (func_name_node->type == AST_DOT) {
            // This is a dot expression like m.abs
            char library_name[256];
            char function_name[256];
            
            // Extract library name from the left side of the dot
            if (func_name_node->children[0].type == AST_EXPR && func_name_node->children[0].text) {
                strcpy(library_name, func_name_node->children[0].text);
            } else {
                fprintf(stderr, "Error: Invalid library name in dot expression\n");
                return 0;
            }
            
            // Extract function name from the right side of the dot
            if (func_name_node->children[1].type == AST_EXPR && func_name_node->children[1].text) {
                strcpy(function_name, func_name_node->children[1].text);
            } else {
                fprintf(stderr, "Error: Invalid function name in dot expression\n");
                return 0;
            }
            
            // Check if this alias is imported
            const char* actual_library = get_library_alias(library_name);
            if (actual_library) {
                
                // Now implement the actual function calls
                if (strcmp(actual_library, "math") == 0) {
                    return call_math_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "util") == 0) {
                    return call_util_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "core") == 0) {
                    return call_core_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "file_io") == 0) {
                    return call_file_io_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "array") == 0) {
                    return call_array_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "object") == 0) {
                    return call_object_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "path_utils") == 0) {
                    return call_path_utils_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "env") == 0) {
                    return call_env_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "args") == 0) {
                    return call_args_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "process") == 0) {
                    return call_process_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "text_utils") == 0) {
                    return call_text_utils_function(function_name, &ast->children[1]);
                } else if (strcmp(actual_library, "debug") == 0) {
                    return call_debug_function(function_name, &ast->children[1]);
                }
                
                return 0;
            } else {
                fprintf(stderr, "Error: Alias '%s' not imported. Use 'use <library> as %s;' first\n", library_name, library_name);
                return 0;
            }
        }
        
        // Check for dot expressions that are not function calls (e.g., m.PI, m.E)
        if (func_name_node->type == AST_DOT && ast->child_count < 2) {
            // This is a dot expression like m.PI (no arguments)
            char library_name[256];
            char constant_name[256];
            
            // Extract library name from the left side of the dot
            if (func_name_node->children[0].type == AST_EXPR && func_name_node->children[0].text) {
                strcpy(library_name, func_name_node->children[0].text);
            } else {
                fprintf(stderr, "Error: Invalid library name in dot expression\n");
                return 0;
            }
            
            // Extract constant name from the right side of the dot
            if (func_name_node->children[1].type == AST_EXPR && func_name_node->children[1].text) {
                strcpy(constant_name, func_name_node->children[1].text);
            } else {
                fprintf(stderr, "Error: Invalid constant name in dot expression\n");
                return 0;
            }
            
            // Check if this alias is imported
            const char* actual_library = get_library_alias(library_name);
            if (actual_library) {
                // Handle library constants
                if (strcmp(actual_library, "math") == 0) {
                    if (strcmp(constant_name, "PI") == 0) {
                        return (long long)(3.141592653589793 * 1000000);
                    } else if (strcmp(constant_name, "E") == 0) {
                        return (long long)(2.718281828459045 * 1000000);
                    } else if (strcmp(constant_name, "INF") == 0) {
                        return 999999999;
                    } else if (strcmp(constant_name, "NAN") == 0) {
                        return -999999999;
                    }
                }
                
                fprintf(stderr, "Error: Unknown constant '%s' in library '%s'\n", constant_name, actual_library);
                return 0;
            } else {
                fprintf(stderr, "Error: Alias '%s' not imported. Use 'use <library> as %s;' first\n", library_name, library_name);
                return 0;
            }
        }
        
        if (func_name && strcmp(func_name, "len") == 0) {
            // len() function - works with strings and arrays
            if (ast->child_count < 2) {
                fprintf(stderr, "Error: len() function requires one argument\n");
                return 0;
            }
            
            ASTNode* arg_node = &ast->children[1].children[0];
            
            // Check AST node type first for literals
            if (arg_node->type == AST_ARRAY_LITERAL) {
                // Array literal - count the children
                return (long long)arg_node->child_count;
            } else if (arg_node->type == AST_OBJECT_LITERAL) {
                // Object literal - count the properties
                return (long long)arg_node->child_count;
            } else if (arg_node->type == AST_EXPR && arg_node->text && is_string_literal(arg_node->text)) {
                // String literal - get its length directly from the AST
                size_t len = strlen(arg_node->text);
                if (len >= 2) {
                    // Extract string content (remove quotes)
                    size_t content_len = len - 2;
                    return (long long)content_len;
                }
                return 0;
            }
            
            // For variables, evaluate and check the result
            long long arg_value = eval_expression(arg_node);
            
            if (arg_value == -1) {
                // String variable - get its length
                if (arg_node->text) {
                    const char* str_val = get_str_value(arg_node->text);
                    if (str_val) {
                        return (long long)strlen(str_val);
                    }
                }
                return 0;
            } else if (arg_value == -2) {
                // Array variable - get its size
                if (arg_node->text) {
                    MycoArray* array = get_array_value(arg_node->text);
                    if (array) {
                        return (long long)array->size;
                    }
                }
                return 0;
            } else if (arg_value >= 0) {
                // Numeric value - return 1 (length of a single number)
                return 1;
            } else {
                // Unknown type
                fprintf(stderr, "Error: core.len() argument must be an array or string\n");
                return 0;
            }
        } else if (func_name && strcmp(func_name, "push") == 0) {
            // push(array, value) - add element to array
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: push() function requires two arguments\n");
                return 0;
            }
            
            // Get array name from first argument
            ASTNode* array_node = &ast->children[1].children[0];


            
            if (array_node->type == AST_EXPR && array_node->text) {
                // Extract the actual variable name from the string literal
                const char* array_name = array_node->text;
                if (is_string_literal(array_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(array_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, array_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            array_name = temp_name;
                        }
                    }
                }
                
                MycoArray* array = get_array_value(array_name);

                if (array) {
                    // Evaluate the value to add
                    long long value_to_add = eval_expression(&ast->children[1].children[1]);
                    if (error_occurred) return 0;
                    
                    // Add the value to the array
                    if (array->is_string_array) {
                        // For string arrays, we need to handle string values
                        if (value_to_add == -1) {
                            // String variable - get its value
                            const char* str_val = get_str_value(array_node->text);
                            if (str_val) {
                                array_push(array, strdup(str_val));
                                return (long long)array->size;
                            }
                        } else if (value_to_add == 1) {
                            // String literal - extract from AST
                            if (ast->children[1].children[1].type == AST_EXPR && 
                                ast->children[1].children[1].text && 
                                is_string_literal(ast->children[1].children[1].text)) {
                                size_t len = strlen(ast->children[1].children[1].text);
                                if (len >= 2) {
                                    char* str_val = tracked_strdup(ast->children[1].children[1].text + 1, __FILE__, __LINE__, "eval");
                                    str_val[len - 2] = '\0';
                                    array_push(array, str_val);
                                    return (long long)array->size;
                                }
                            }
                        }
                    } else {
                        // Numeric array
                        array_push(array, &value_to_add);
                        return (long long)array->size;
                    }
                }
            }
            return 0;
        } else if (func_name && strcmp(func_name, "pop") == 0) {
            // pop(array) - remove and return last element
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: pop() function requires one argument\n");
                            return 0;
            }
            
            ASTNode* array_node = &ast->children[1].children[0];
            if (array_node->type == AST_EXPR && array_node->text) {
                // Extract the actual variable name from the string literal
                const char* array_name = array_node->text;
                if (is_string_literal(array_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(array_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, array_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            array_name = temp_name;
                        }
                    }
                }
                
                MycoArray* array = get_array_value(array_name);
                if (array && array->size > 0) {
                    if (array->is_string_array) {
                        // For string arrays, return the last string
                        const char* last_str = array_get_string(array, array->size - 1);
                        if (last_str) {
                                                    // Store the popped string in a predictable variable
                        // Clear other results to avoid conflicts
                        set_str_value("__last_first_result", "");
                        set_str_value("__last_last_result", "");
                        set_str_value("__last_tostring_result", "");
                        set_str_value("__last_pop_result", strdup(last_str));
                        
                        // Remove the last element
                        array->size--;
                        return -1; // Indicate string result
                        }
                    } else {
                        // For numeric arrays, return the last number
                        long long* last_num = (long long*)array_get(array, array->size - 1);
                        if (last_num) {
                            long long result = *last_num;
                            array->size--;
                            return result;
                        }
                    }
                }
            }
            return 0;
        } else if (func_name && strcmp(func_name, "slice") == 0) {
            // slice(array, start, end) - extract portion of array
            if (ast->child_count < 2 || ast->children[1].child_count < 3) {
                fprintf(stderr, "Error: slice() function requires three arguments\n");
                return 0;
            }
            
            // Get array argument
            ASTNode* array_node = &ast->children[1].children[0];
            if (array_node->type == AST_EXPR && array_node->text) {
                const char* array_name = array_node->text;
                MycoArray* source_array = get_array_value(array_name);
                if (!source_array) {
                    return 0;
                }
                
                // Get start and end indices
                long long start_idx = eval_expression(&ast->children[1].children[1]);
                long long end_idx = eval_expression(&ast->children[1].children[2]);
                
                // Validate indices
                if (start_idx < 0) start_idx = 0;
                if (end_idx > source_array->size) end_idx = source_array->size;
                if (start_idx >= end_idx) {
                    // Return empty array
                    MycoArray* result_array = create_array(1, source_array->is_string_array);
                    set_array_value("__last_slice_result", result_array);
                    return -2;
                }
                
                // Create new array with sliced elements
                int slice_size = (int)(end_idx - start_idx);
                MycoArray* result_array = create_array(slice_size, source_array->is_string_array);
                
                if (source_array->is_string_array) {
                    // Copy string elements
                    for (int i = 0; i < slice_size; i++) {
                        const char* str_elem = array_get_string(source_array, (int)start_idx + i);
                        if (str_elem) {
                            array_push(result_array, strdup(str_elem));
                        }
                    }
                        } else {
                    // Copy numeric elements
                    for (int i = 0; i < slice_size; i++) {
                        long long* num_elem = (long long*)array_get(source_array, (int)start_idx + i);
                        if (num_elem) {
                            long long* new_elem = (long long*)tracked_malloc(sizeof(long long), __FILE__, __LINE__, "slice_element");
                            *new_elem = *num_elem;
                            array_push(result_array, new_elem);
                        }
                    }
                }
                
                // Store result and return array indicator
                set_array_value("__last_slice_result", result_array);
                return -2;
            }
            return 0;
        } else if (func_name && strcmp(func_name, "join") == 0) {
            // join(array, separator) - join array elements with separator
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: join() function requires two arguments\n");
                            return 0;
                        }
            
            // Get array argument
            ASTNode* array_node = &ast->children[1].children[0];
            if (array_node->type == AST_EXPR && array_node->text) {
                const char* array_name = array_node->text;
                MycoArray* source_array = get_array_value(array_name);
                if (!source_array || source_array->size == 0) {
                    // Return empty string for empty array
                    set_str_value("__last_join_result", "");
                    return -1;
                }
                
                // Get separator
                long long sep_result = eval_expression(&ast->children[1].children[1]);
                const char* separator = "";
                if (sep_result == 1) {
                    // String literal separator
                    ASTNode* sep_node = &ast->children[1].children[1];
                    if (sep_node->text && is_string_literal(sep_node->text)) {
                        size_t len = strlen(sep_node->text);
                        if (len >= 2) {
                            char* temp_sep = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "join_separator");
                            strncpy(temp_sep, sep_node->text + 1, len - 2);
                            temp_sep[len - 2] = '\0';
                            separator = temp_sep;
                        }
                    }
                } else if (sep_result == -1) {
                    // String variable separator
                    ASTNode* sep_node = &ast->children[1].children[1];
                    if (sep_node->text) {
                        const char* sep_var = get_str_value(sep_node->text);
                        if (sep_var) {
                            separator = sep_var;
                        }
                    }
                }
                
                // Calculate total length needed
                size_t total_length = 0;
                size_t sep_len = strlen(separator);
                
                for (int i = 0; i < source_array->size; i++) {
                    if (source_array->is_string_array) {
                        const char* str_elem = array_get_string(source_array, i);
                        if (str_elem) {
                            total_length += strlen(str_elem);
                        }
                    } else {
                        // Convert number to string (estimate 20 chars per number)
                        total_length += 20;
                    }
                    if (i < source_array->size - 1) {
                        total_length += sep_len;
                    }
                }
                
                // Build the joined string
                char* result = (char*)tracked_malloc(total_length + 1, __FILE__, __LINE__, "join_result");
                result[0] = '\0';
                
                for (int i = 0; i < source_array->size; i++) {
                    if (source_array->is_string_array) {
                        const char* str_elem = array_get_string(source_array, i);
                        if (str_elem) {
                            strcat(result, str_elem);
                        }
                    } else {
                        long long* num_elem = (long long*)array_get(source_array, i);
                        if (num_elem) {
                            char num_str[32];
                            snprintf(num_str, sizeof(num_str), "%lld", *num_elem);
                            strcat(result, num_str);
                        }
                    }
                    if (i < source_array->size - 1) {
                        strcat(result, separator);
                    }
                }
                
                // Store result and return string indicator
                set_str_value("__last_join_result", result);
                return -1;
            }
            return 0;
        } else if (func_name && strcmp(func_name, "split") == 0) {
            // split(string, delimiter) - split string into array
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: split() function requires two arguments\n");
                return 0;
            }
            
            // Get string argument
            ASTNode* string_node = &ast->children[1].children[0];
            const char* source_string = NULL;
            
            if (string_node->type == AST_EXPR && string_node->text) {
                long long str_result = eval_expression(string_node);
                if (str_result == 1) {
                    // String literal
                    if (is_string_literal(string_node->text)) {
                        size_t len = strlen(string_node->text);
                        if (len >= 2) {
                            char* temp_str = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "split_string");
                            strncpy(temp_str, string_node->text + 1, len - 2);
                            temp_str[len - 2] = '\0';
                            source_string = temp_str;
                        }
                    }
                } else if (str_result == -1) {
                    // String variable
                    const char* str_var = get_str_value(string_node->text);
                    if (str_var) {
                        source_string = str_var;
                    }
                }
            }
            
            if (!source_string) {
                // Return empty array
                MycoArray* result_array = create_array(1, 1); // string array
                set_array_value("__last_split_result", result_array);
                return -2;
            }
            
            // Get delimiter
            ASTNode* delim_node = &ast->children[1].children[1];
            const char* delimiter = "";
            long long delim_result = eval_expression(delim_node);
            
            if (delim_result == 1) {
                // String literal delimiter
                if (delim_node->text && is_string_literal(delim_node->text)) {
                    size_t len = strlen(delim_node->text);
                    if (len >= 2) {
                        char* temp_delim = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "split_delimiter");
                        strncpy(temp_delim, delim_node->text + 1, len - 2);
                        temp_delim[len - 2] = '\0';
                        delimiter = temp_delim;
                    }
                }
            } else if (delim_result == -1) {
                // String variable delimiter
                const char* delim_var = get_str_value(delim_node->text);
                if (delim_var) {
                    delimiter = delim_var;
                }
            }
            
            // Perform the split
            MycoArray* result_array = create_array(1, 1); // string array
            
            if (strlen(delimiter) == 0) {
                // Empty delimiter - split into individual characters
                size_t str_len = strlen(source_string);
                for (size_t i = 0; i < str_len; i++) {
                    char* char_str = (char*)tracked_malloc(2, __FILE__, __LINE__, "split_char");
                    char_str[0] = source_string[i];
                    char_str[1] = '\0';
                    array_push(result_array, char_str);
                }
            } else {
                // Split by delimiter
                char* str_copy = tracked_strdup(source_string, __FILE__, __LINE__, "eval");
                char* saveptr;
                char* token = strtok_r(str_copy, delimiter, &saveptr);
                
                while (token != NULL) {
                    array_push(result_array, strdup(token));
                    token = strtok_r(NULL, delimiter, &saveptr);
                }
                
                tracked_free(str_copy, __FILE__, __LINE__, "split_string_copy");
            }
            
            // Store result and return array indicator
            set_array_value("__last_split_result", result_array);
            return -2;
        } else if (func_name && strcmp(func_name, "trim") == 0) {
            // trim(string) - remove whitespace from beginning and end
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: trim() function requires one argument\n");
                return 0;
            }
            
            // Get string argument
            ASTNode* string_node = &ast->children[1].children[0];
            const char* source_string = NULL;
            
            if (string_node->type == AST_EXPR && string_node->text) {
                long long str_result = eval_expression(string_node);
                if (str_result == 1) {
                    // String literal
                    if (is_string_literal(string_node->text)) {
                        size_t len = strlen(string_node->text);
                        if (len >= 2) {
                            char* temp_str = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "trim_string");
                            strncpy(temp_str, string_node->text + 1, len - 2);
                            temp_str[len - 2] = '\0';
                            source_string = temp_str;
                        }
                    }
                } else if (str_result == -1) {
                    // String variable
                    const char* str_var = get_str_value(string_node->text);
                    if (str_var) {
                        source_string = str_var;
                    }
                }
            }
            
            if (!source_string) {
                // Return empty string
                set_str_value("__last_trim_result", "");
                return -1;
            }
            
            // Trim whitespace
            const char* start = source_string;
            const char* end = source_string + strlen(source_string) - 1;
            
            // Skip leading whitespace
            while (*start && (*start == ' ' || *start == '\t' || *start == '\n' || *start == '\r')) {
                start++;
            }
            
            // Skip trailing whitespace
            while (end > start && (*end == ' ' || *end == '\t' || *end == '\n' || *end == '\r')) {
                end--;
            }
            
            // Create trimmed string
            size_t trimmed_len = end - start + 1;
            char* trimmed_string = (char*)tracked_malloc(trimmed_len + 1, __FILE__, __LINE__, "trim_result");
            strncpy(trimmed_string, start, trimmed_len);
            trimmed_string[trimmed_len] = '\0';
            
            // Store result and return string indicator
            set_str_value("__last_trim_result", trimmed_string);
            return -1;
        } else if (func_name && strcmp(func_name, "replace") == 0) {
            // replace(string, old, new) - replace occurrences of old with new
            if (ast->child_count < 2 || ast->children[1].child_count < 3) {
                fprintf(stderr, "Error: replace() function requires three arguments\n");
                return 0;
            }
            
            // Get string argument
            ASTNode* string_node = &ast->children[1].children[0];
            const char* source_string = NULL;
            
            if (string_node->type == AST_EXPR && string_node->text) {
                long long str_result = eval_expression(string_node);
                if (str_result == 1) {
                    // String literal
                    if (is_string_literal(string_node->text)) {
                        size_t len = strlen(string_node->text);
                        if (len >= 2) {
                            char* temp_str = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "replace_string");
                            strncpy(temp_str, string_node->text + 1, len - 2);
                            temp_str[len - 2] = '\0';
                            source_string = temp_str;
                        }
                    }
                } else if (str_result == -1) {
                    // String variable
                    const char* str_var = get_str_value(string_node->text);
                    if (str_var) {
                        source_string = str_var;
                    }
                }
            }
            
            if (!source_string) {
                set_str_value("__last_replace_result", "");
                return -1;
            }
            
            // Get old string argument
            ASTNode* old_node = &ast->children[1].children[1];
            const char* old_string = "";
            long long old_result = eval_expression(old_node);
            
            if (old_result == 1) {
                // String literal
                if (old_node->text && is_string_literal(old_node->text)) {
                    size_t len = strlen(old_node->text);
                    if (len >= 2) {
                        char* temp_old = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "replace_old");
                        strncpy(temp_old, old_node->text + 1, len - 2);
                        temp_old[len - 2] = '\0';
                        old_string = temp_old;
                    }
                }
            } else if (old_result == -1) {
                // String variable
                const char* old_var = get_str_value(old_node->text);
                if (old_var) {
                    old_string = old_var;
                }
            }
            
            // Get new string argument
            ASTNode* new_node = &ast->children[1].children[2];
            const char* new_string = "";
            long long new_result = eval_expression(new_node);
            
            if (new_result == 1) {
                // String literal
                if (new_node->text && is_string_literal(new_node->text)) {
                    size_t len = strlen(new_node->text);
                    if (len >= 2) {
                        char* temp_new = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "replace_new");
                        strncpy(temp_new, new_node->text + 1, len - 2);
                        temp_new[len - 2] = '\0';
                        new_string = temp_new;
                    }
                }
            } else if (new_result == -1) {
                // String variable
                const char* new_var = get_str_value(new_node->text);
                if (new_var) {
                    new_string = new_var;
                }
            }
            
            // Perform the replacement
            if (strlen(old_string) == 0) {
                // Can't replace empty string, return original
                set_str_value("__last_replace_result", strdup(source_string));
                return -1;
            }
            
            // Count occurrences to determine result size
            const char* pos = source_string;
            int count = 0;
            size_t old_len = strlen(old_string);
            size_t new_len = strlen(new_string);
            
            while ((pos = strstr(pos, old_string)) != NULL) {
                count++;
                pos += old_len;
            }
            
            if (count == 0) {
                // No replacements needed
                set_str_value("__last_replace_result", strdup(source_string));
                return -1;
            }
            
            // Calculate result size
            size_t source_len = strlen(source_string);
            size_t result_len = source_len - (count * old_len) + (count * new_len);
            char* result = (char*)tracked_malloc(result_len + 1, __FILE__, __LINE__, "replace_result");
            
            // Perform replacements
            const char* src_pos = source_string;
            char* dest_pos = result;
            
            while ((pos = strstr(src_pos, old_string)) != NULL) {
                // Copy part before the match
                size_t prefix_len = pos - src_pos;
                strncpy(dest_pos, src_pos, prefix_len);
                dest_pos += prefix_len;
                
                // Copy the replacement
                strcpy(dest_pos, new_string);
                dest_pos += new_len;
                
                // Move past the old string
                src_pos = pos + old_len;
            }
            
            // Copy remaining part
            strcpy(dest_pos, src_pos);
            
            // Store result and return string indicator
            set_str_value("__last_replace_result", result);
            return -1;
        } else if (func_name && strcmp(func_name, "object_keys") == 0) {
            // object_keys(obj) - return array of property names
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: object_keys() function requires one argument\n");
                return 0;
            }
            
            ASTNode* obj_node = &ast->children[1].children[0];
            if (obj_node->type == AST_EXPR && obj_node->text) {
                // Extract the actual variable name from the string literal
                const char* obj_name = obj_node->text;
                if (is_string_literal(obj_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(obj_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, obj_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            obj_name = temp_name;
                        }
                    }
                }
                
                MycoObject* obj = get_object_value(obj_name);

                if (obj && obj->property_count > 0) {
                    // Create a new string array to hold the keys
                    MycoArray* keys_array = create_array(1, 1); // String array

                    if (keys_array) {
                        for (int i = 0; i < obj->property_count; i++) {
                            if (obj->property_names[i]) {

                                array_push(keys_array, strdup(obj->property_names[i]));
                            }
                        }
                        
                        // Store the keys array in a predictable variable name
                        set_array_value("__last_object_keys_result", keys_array);

                        
                        return -2; // Indicate array result
                    }
                }
            }
            return 0;
        } else if (func_name && strcmp(func_name, "values") == 0) {
            // values(obj) - return array of property values
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: values() function requires one argument\n");
                return 0;
            }
            
            ASTNode* obj_node = &ast->children[1].children[0];
            if (obj_node->type == AST_EXPR && obj_node->text) {
                // Extract the actual variable name from the string literal
                const char* obj_name = obj_node->text;
                if (is_string_literal(obj_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(obj_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, obj_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            obj_name = temp_name;
                        }
                    }
                }
                
                MycoObject* obj = get_object_value(obj_name);
                if (obj && obj->property_count > 0) {
                    // Create a new array to hold the values (mixed types)
                    MycoArray* values_array = create_array(1, 0); // Start as numeric array, convert if needed
                    if (values_array) {
                        // Determine if we need a string array by checking the first value
                        int needs_string_array = 0;
                        for (int i = 0; i < obj->property_count; i++) {
                            void* prop_value = obj->property_values[i];
                            if ((long long)prop_value > 1000000) {
                                // Check if this looks like a string
                                char* str_value = (char*)prop_value;
                                if (str_value && str_value[0] != '\0' && 
                                    ((str_value[0] >= 'A' && str_value[0] <= 'Z') || 
                                     (str_value[0] >= 'a' && str_value[0] <= 'z') ||
                                     str_value[0] == ' ' || str_value[0] == '_')) {
                                    needs_string_array = 1;
                                    break;
                                }
                            }
                        }
                        
                        // Convert to string array if needed
                        if (needs_string_array) {
                            values_array->is_string_array = 1;
                            values_array->str_elements = (char**)tracked_malloc(values_array->capacity * sizeof(char*), __FILE__, __LINE__, "values_str_array");
                            // Initialize string elements
                            for (int i = 0; i < values_array->capacity; i++) {
                                values_array->str_elements[i] = NULL;
                            }
                        }
                        
                        // Add all property values to the array
                        for (int i = 0; i < obj->property_count; i++) {
                            void* prop_value = obj->property_values[i];
                            
                            if (needs_string_array) {
                                // Convert all values to strings
                                if ((long long)prop_value > 1000000) {
                                    char* str_value = (char*)prop_value;
                                    if (str_value && str_value[0] != '\0' && 
                                        ((str_value[0] >= 'A' && str_value[0] <= 'Z') || 
                                         (str_value[0] >= 'a' && str_value[0] <= 'z') ||
                                         str_value[0] == ' ' || str_value[0] == '_')) {
                                        array_push(values_array, strdup(str_value));
                        } else {
                                        // Convert number to string
                                        char num_str[32];
                                        snprintf(num_str, sizeof(num_str), "%lld", (long long)prop_value);
                                        array_push(values_array, strdup(num_str));
                                    }
                                } else {
                                    // Convert number to string
                                    char num_str[32];
                                    snprintf(num_str, sizeof(num_str), "%lld", (long long)prop_value);
                                    array_push(values_array, strdup(num_str));
                                }
                            } else {
                                // Keep as numeric array
                                long long* value_ptr = (long long*)tracked_malloc(sizeof(long long), __FILE__, __LINE__, "values_num");
                                *value_ptr = (long long)prop_value;
                                array_push(values_array, value_ptr);
                            }
                        }
                        
                        // Clear other array results to avoid conflicts
                        set_array_value("__last_object_keys_result", NULL);
                        set_array_value("__last_split_result", NULL);
                        set_array_value("__last_slice_result", NULL);
                        
                        // Store the values array in a predictable variable name
                        set_array_value("__last_values_result", values_array);
                        return -2; // Indicate array result
                    }
                }
            }
            return 0;
        } else if (func_name && strcmp(func_name, "has_key") == 0) {
            // has_key(obj, key) - check if object has a property
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: has_key() function requires two arguments\n");
                            return 0;
            }
            
            // Get object argument
            ASTNode* obj_node = &ast->children[1].children[0];
            const char* obj_name = NULL;
            if (obj_node->type == AST_EXPR && obj_node->text) {
                obj_name = obj_node->text;
                if (is_string_literal(obj_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(obj_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, obj_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            obj_name = temp_name;
                        }
                    }
                }
            }
            
            // Get key argument
            ASTNode* key_node = &ast->children[1].children[1];
            const char* key_name = NULL;
            if (key_node->type == AST_EXPR && key_node->text) {
                key_name = key_node->text;
                if (is_string_literal(key_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(key_name);
                    if (len >= 2) {
                        char* temp_key = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_key) {
                            strncpy(temp_key, key_name + 1, len - 2);
                            temp_key[len - 2] = '\0';
                            key_name = temp_key;
                        }
                    }
                }
            }
            
            if (obj_name && key_name) {
                MycoObject* obj = get_object_value(obj_name);
                if (obj) {
                    // Use the existing object_has_property function
                    return object_has_property(obj, key_name) ? 1 : 0;
                }
            }
            return 0; // Object not found or invalid arguments
        } else if (func_name && strcmp(func_name, "set_has") == 0) {
            // set_has(set, element) - check if set contains element
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: set_has() function requires two arguments\n");
                return 0;
            }
            
            // Get set argument
            ASTNode* set_node = &ast->children[1].children[0];
            const char* set_name = NULL;
            if (set_node->type == AST_EXPR && set_node->text) {
                set_name = set_node->text;
            }
            
            MycoSet* set = get_set_value(set_name);
            if (!set) {
                fprintf(stderr, "Error: First argument to set_has() must be a set\n");
                return 0;
            }
            
            // Get element to check
            long long element_value = eval_expression(&ast->children[1].children[1]);
            if (error_occurred) return 0;
            
            // Check if element exists in set
            if (set->is_string_set) {
                // For string sets, check if it's a string literal or variable
                if (element_value == -1) {
                    // String variable
                    const char* str_value = get_str_value(ast->children[1].children[1].text);
                    if (str_value) {
                        return set_has(set, (void*)str_value) ? 1 : 0;
                    }
                } else if (element_value == 1 && ast->children[1].children[1].text && 
                          ast->children[1].children[1].text[0] == '"') {
                    // String literal
                    char* str_literal = ast->children[1].children[1].text;
                    size_t len = strlen(str_literal);
                    if (len >= 2) {
                        char* temp_str = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_str) {
                            strncpy(temp_str, str_literal + 1, len - 2);
                            temp_str[len - 2] = '\0';
                            int result = set_has(set, (void*)temp_str) ? 1 : 0;
                            free(temp_str);
                            return result;
                        }
                    }
                }
                return 0;
                        } else {
                // For numeric sets
                return set_has(set, (void*)&element_value) ? 1 : 0;
            }
        } else if (func_name && strcmp(func_name, "set_add") == 0) {
            // set_add(set, element) - add element to set
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: set_add() function requires two arguments\n");
                            return 0;
                        }
            
            // Get set argument
            ASTNode* set_node = &ast->children[1].children[0];
            const char* set_name = NULL;
            if (set_node->type == AST_EXPR && set_node->text) {
                set_name = set_node->text;
            }
            
            MycoSet* set = get_set_value(set_name);
            if (!set) {
                fprintf(stderr, "Error: First argument to set_add() must be a set\n");
                return 0;
            }
            
            // Get element to add
            long long element_value = eval_expression(&ast->children[1].children[1]);
            if (error_occurred) return 0;
            
            // Add element to set
            if (set->is_string_set) {
                // Handle string elements
                if (element_value == -1) {
                    // String variable
                    const char* str_value = get_str_value(ast->children[1].children[1].text);
                    if (str_value) {
                        return set_add(set, (void*)str_value) ? 1 : 0;
                    }
                } else if (element_value == 1 && ast->children[1].children[1].text && 
                          ast->children[1].children[1].text[0] == '"') {
                    // String literal
                    char* str_literal = ast->children[1].children[1].text;
                    size_t len = strlen(str_literal);
                    if (len >= 2) {
                        char* temp_str = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_str) {
                            strncpy(temp_str, str_literal + 1, len - 2);
                            temp_str[len - 2] = '\0';
                            int result = set_add(set, (void*)temp_str) ? 1 : 0;
                            free(temp_str);
                            return result;
                        }
                    }
                }
                return 0;
            } else {
                // For numeric sets
                return set_add(set, (void*)&element_value) ? 1 : 0;
            }
        } else if (func_name && strcmp(func_name, "set_size") == 0) {
            // set_size(set) - return number of elements in set
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: set_size() function requires one argument\n");
                return 0;
            }
            
            // Get set argument
            ASTNode* set_node = &ast->children[1].children[0];
            const char* set_name = NULL;
            if (set_node->type == AST_EXPR && set_node->text) {
                set_name = set_node->text;
            }
            
            MycoSet* set = get_set_value(set_name);
            if (set) {
                return set_size(set);
            }
            return 0; // Set not found
        } else if (func_name && strcmp(func_name, "size") == 0) {
            // size(obj) - return number of properties in object
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: size() function requires one argument\n");
                return 0;
            }
            
            ASTNode* obj_node = &ast->children[1].children[0];
            if (obj_node->type == AST_EXPR && obj_node->text) {
                // Extract the actual variable name from the string literal
                const char* obj_name = obj_node->text;
                if (is_string_literal(obj_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(obj_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, obj_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            obj_name = temp_name;
                        }
                    }
                }
                
                MycoObject* obj = get_object_value(obj_name);
                if (obj) {
                    return obj->property_count;
                }
            }
            return 0; // Object not found or no properties
        } else if (func_name && strcmp(func_name, "remove") == 0) {
            // remove(obj, key) - delete property from object
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: remove() function requires two arguments\n");
                return 0;
            }
            
            // Get object argument
            ASTNode* obj_node = &ast->children[1].children[0];
            const char* obj_name = NULL;
            if (obj_node->type == AST_EXPR && obj_node->text) {
                obj_name = obj_node->text;
                if (is_string_literal(obj_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(obj_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, obj_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            obj_name = temp_name;
                        }
                    }
                }
            }
            
            // Get key argument
            ASTNode* key_node = &ast->children[1].children[1];
            const char* key_name = NULL;
            if (key_node->type == AST_EXPR && key_node->text) {
                if (is_string_literal(key_node->text)) {
                    // String literal - remove quotes
                    key_name = key_node->text;
                    size_t len = strlen(key_name);
                    if (len >= 2) {
                        char* temp_key = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_key) {
                            strncpy(temp_key, key_name + 1, len - 2);
                            temp_key[len - 2] = '\0';
                            key_name = temp_key;
                        }
                    }
            } else {
                    // Variable - get string value
                    key_name = get_str_value(key_node->text);
                }
            }
            
            if (obj_name && key_name) {
                MycoObject* obj = get_object_value(obj_name);
                if (obj) {
                    // Find property index
                    int index = -1;
                    for (int i = 0; i < obj->property_count; i++) {
                        if (obj->property_names[i] && strcmp(obj->property_names[i], key_name) == 0) {
                            index = i;
                            break;
                        }
                    }
                    
                    if (index != -1) {
                        // Free memory for removed property name
                        tracked_free(obj->property_names[index], __FILE__, __LINE__, "remove_property_name");
                        
                        // Shift arrays left to fill gap
                        for (int i = index; i < obj->property_count - 1; i++) {
                            obj->property_names[i] = obj->property_names[i + 1];
                            obj->property_values[i] = obj->property_values[i + 1];
                        }
                        
                        // Update count
                        obj->property_count--;
                        
                        return 1; // Success
                    }
                }
            }
            return 0; // Object not found, property not found, or invalid arguments
        } else if (func_name && strcmp(func_name, "filter") == 0) {
            // filter(array, condition) - filter array elements based on condition or lambda
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: filter() function requires two arguments\n");
                return 0;
            }
            
            // Get array argument
            ASTNode* array_node = &ast->children[1].children[0];
            const char* array_name = NULL;
            if (array_node->type == AST_EXPR && array_node->text) {
                array_name = array_node->text;
            }
            
            MycoArray* array = get_array_value(array_name);
            if (!array) {
                fprintf(stderr, "Error: First argument to filter() must be an array\n");
                return 0;
            }
            
            // Check if second argument is a lambda function
            ASTNode* condition_node = &ast->children[1].children[1];
            if (condition_node->type == AST_EXPR && condition_node->text) {
                // Check if this is a lambda function call
                ASTNode* lambda_func = get_lambda_value(condition_node->text);
                if (lambda_func) {
                    // Lambda-based filtering
                    MycoArray* result = create_array(10, array->is_string_array);
                    if (!result) {
                        fprintf(stderr, "Error: Failed to create result array\n");
                        return 0;
                    }
                    
                    // Filter elements using lambda
                    for (int i = 0; i < array->size; i++) {
                        // Get the current array element
                        long long elem_value = 0;
                        const char* str_elem = NULL;
                        
                        if (array->is_string_array) {
                            str_elem = (const char*)array->str_elements[i];
                            // For string arrays, we'll use the string length as the numeric value
                            elem_value = strlen(str_elem);
                        } else {
                            elem_value = array->elements[i];
                        }
                        
                        // Set the lambda parameter as a variable in the current scope
                        // Handle different lambda parameter types
                        if (lambda_func->children[0].type == AST_EXPR && 
                            lambda_func->children[0].text) {
                            
                            if (strcmp(lambda_func->children[0].text, "params") != 0) {
                                // Single parameter lambda: x => expression
                                char* param_name = lambda_func->children[0].text;
                                set_var_value(param_name, elem_value);
                                
                                // Execute lambda body
                                long long lambda_result = eval_expression(&lambda_func->children[1]);
                                
                                // If lambda returns true (non-zero), include element
                                if (lambda_result != 0) {
                                    if (array->is_string_array) {
                                        array_push(result, (void*)str_elem);
                                    } else {
                                        // Get the original array element, not the local variable
                                        long long original_elem = array->elements[i];
                                        array_push(result, &original_elem);
                                    }
                                }
                            } else if (lambda_func->children[0].child_count == 1) {
                                // Single parameter lambda: (x) => expression
                                char* param_name = lambda_func->children[0].children[0].text;
                                set_var_value(param_name, elem_value);
                                
                                // Execute lambda body
                                long long lambda_result = eval_expression(&lambda_func->children[1]);
                                
                                // If lambda returns true (non-zero), include element
                                if (lambda_result != 0) {
                                    if (array->is_string_array) {
                                        array_push(result, (void*)str_elem);
                                    } else {
                                        array_push(result, &elem_value);
                                    }
                                }
                            }
                        }
                    }
                    
                    // Store result and return the array name
                    // Store result in the standard location
                    set_array_value("__last_filter_result", result);
                    return -2; // Indicate array result
                }
            }
            
            // Fallback to original numeric condition-based filtering
            long long condition = eval_expression(&ast->children[1].children[1]);
            if (error_occurred) return 0;
            
            // Create result array
            MycoArray* result = create_array(10, array->is_string_array);
            if (!result) {
                fprintf(stderr, "Error: Failed to create result array\n");
                return 0;
            }
            
            // Filter elements
            for (int i = 0; i < array->size; i++) {
                if (array->is_string_array) {
                    // For string arrays, filter by string length or non-empty strings
                    const char* str_elem = (const char*)array->str_elements[i];
                    if (str_elem && ((condition == 0 && strlen(str_elem) > 0) || 
                                   (condition == 1 && strlen(str_elem) > 5))) {
                        array_push(result, (void*)str_elem);
                    }
                } else {
                    // For number arrays, filter by comparison with condition
                    long long elem = array->elements[i];
                    if ((condition == 0 && elem > 0) || 
                        (condition == 1 && elem % 2 == 0) || 
                        (condition == 2 && elem > 10)) {
                        array_push(result, &elem);
                    }
                }
            }
            
            // Store result
            set_array_value("__last_filter_result", result);
            return -2; // Indicate array result
        } else if (func_name && strcmp(func_name, "map") == 0) {
            // map(array, operation) - transform array elements using operation or lambda
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: map() function requires two arguments\n");
                return 0;
            }
            
            // Get array argument
            ASTNode* array_node = &ast->children[1].children[0];
            const char* array_name = NULL;
            if (array_node->type == AST_EXPR && array_node->text) {
                array_name = array_node->text;
            }
            
            MycoArray* array = get_array_value(array_name);
            if (!array) {
                fprintf(stderr, "Error: First argument to map() must be an array\n");
                return 0;
            }
            
            // Check if second argument is a lambda function
            ASTNode* operation_node = &ast->children[1].children[1];
            if (operation_node->type == AST_EXPR && operation_node->text) {
                // Check if this is a lambda function call
                ASTNode* lambda_func = get_lambda_value(operation_node->text);
                if (lambda_func) {
                    // Lambda-based mapping
                    MycoArray* result = create_array(10, 0); // numeric array for lambda results
                    if (!result) {
                        fprintf(stderr, "Error: Failed to create result array\n");
                        return 0;
                    }
                    
                    // Transform elements using lambda
                    for (int i = 0; i < array->size; i++) {
                        // Get the current array element
                        long long elem_value = 0;
                        
                        if (array->is_string_array) {
                            const char* str_elem = (const char*)array->str_elements[i];
                            // For string arrays, we'll use the string length as the numeric value
                            elem_value = strlen(str_elem);
                        } else {
                            elem_value = array->elements[i];
                        }
                        
                        // Set the lambda parameter as a variable in the current scope
                        // Handle different lambda parameter types
                        if (lambda_func->children[0].type == AST_EXPR && 
                            lambda_func->children[0].text) {
                            
                            if (strcmp(lambda_func->children[0].text, "params") != 0) {
                                // Single parameter lambda: x => expression
                                char* param_name = lambda_func->children[0].text;
                                set_var_value(param_name, elem_value);
                                
                                // Execute lambda body
                                long long lambda_result = eval_expression(&lambda_func->children[1]);
                                
                                // Store the lambda result
                                array_push(result, &lambda_result);
                            } else if (lambda_func->children[0].child_count == 1) {
                                // Single parameter lambda: (x) => expression
                                char* param_name = lambda_func->children[0].children[0].text;
                                set_var_value(param_name, elem_value);
                                
                                // Execute lambda body
                                long long lambda_result = eval_expression(&lambda_func->children[1]);
                                
                                // Store the lambda result
                                array_push(result, &lambda_result);
                            }
                        }
                    }
                    
                    // Store result
                    set_array_value("__last_map_result", result);
                    return -2; // Indicate array result
                }
            }
            
            // Fallback to original numeric operation-based mapping
            long long operation = eval_expression(&ast->children[1].children[1]);
            if (error_occurred) return 0;
            
            // Create result array (always numeric for mathematical operations)
            MycoArray* result = create_array(10, 0); // numeric array
            if (!result) {
                fprintf(stderr, "Error: Failed to create result array\n");
                return 0;
            }
            
            // Transform elements
            for (int i = 0; i < array->size; i++) {
                long long new_value = 0;
                if (array->is_string_array) {
                    // For string arrays, map to string length or character count
                    const char* str_elem = (const char*)array->str_elements[i];
                    if (str_elem) {
                        if (operation == 0) {
                            new_value = strlen(str_elem); // length
                        } else if (operation == 1) {
                            new_value = str_elem[0]; // first character ASCII
                        } else {
                            new_value = strlen(str_elem) > 3 ? 1 : 0; // long strings -> 1
                        }
                    }
                } else {
                    // For number arrays, apply mathematical operations
                    long long elem = array->elements[i];
                    if (operation == 0) {
                        new_value = elem * 2; // double
                    } else if (operation == 1) {
                        new_value = elem * elem; // square
                    } else if (operation == 2) {
                        new_value = elem + 10; // add 10
                    } else {
                        new_value = elem;
                    }
                }
                array_push(result, &new_value);
            }
            
            // Store result
            set_array_value("__last_map_result", result);
            return -2; // Indicate array result
        } else if (func_name && strcmp(func_name, "reduce") == 0) {
            // reduce(array, operation, initial) - reduce array to single value using operation or lambda
            if (ast->child_count < 2 || ast->children[1].child_count < 3) {
                fprintf(stderr, "Error: reduce() function requires three arguments\n");
                return 0;
            }
            
            // Get array argument
            ASTNode* array_node = &ast->children[1].children[0];
            const char* array_name = NULL;
            if (array_node->type == AST_EXPR && array_node->text) {
                array_name = array_node->text;
            }
            
            MycoArray* array = get_array_value(array_name);
            if (!array) {
                fprintf(stderr, "Error: First argument to reduce() must be an array\n");
                return 0;
            }
            
            // Check if second argument is a lambda function
            ASTNode* operation_node = &ast->children[1].children[1];
            if (operation_node->type == AST_EXPR && operation_node->text) {
                // Check if this is a lambda function call
                ASTNode* lambda_func = get_lambda_value(operation_node->text);
                if (lambda_func) {
                    // Lambda-based reduction
                    long long accumulator = eval_expression(&ast->children[1].children[2]);
                    if (error_occurred) return 0;
                    
                    // Reduce elements using lambda
                    for (int i = 0; i < array->size; i++) {
                        // Get the current array element
                        long long elem_value = 0;
                        
                        if (array->is_string_array) {
                            const char* str_elem = (const char*)array->str_elements[i];
                            // For string arrays, we'll use the string length as the numeric value
                            elem_value = strlen(str_elem);
                        } else {
                            elem_value = array->elements[i];
                        }
                        
                        // Set the lambda parameters as variables in the current scope
                        // For multiple parameter lambdas, we need to extract the parameter names
                        if (lambda_func->children[0].type == AST_EXPR && 
                            lambda_func->children[0].text && 
                            strcmp(lambda_func->children[0].text, "params") == 0 &&
                            lambda_func->children[0].child_count >= 2) {
                            // Multiple parameters lambda: (acc, x) => expression
                            char* acc_param = lambda_func->children[0].children[0].text;
                            char* elem_param = lambda_func->children[0].children[1].text;
                            
                            if (acc_param && elem_param) {
                                set_var_value(acc_param, accumulator);
                                set_var_value(elem_param, elem_value);
                                
                                // Execute lambda body
                                long long lambda_result = eval_expression(&lambda_func->children[1]);
                                
                                // Update accumulator with lambda result
                                accumulator = lambda_result;
                            }
                        }
                    }
                    
                    return accumulator;
                }
            }
            
            // Fallback to original numeric operation-based reduction
            long long operation = eval_expression(&ast->children[1].children[1]);
            if (error_occurred) return 0;
            
            // Get initial value
            long long accumulator = eval_expression(&ast->children[1].children[2]);
            if (error_occurred) return 0;
            
            // Reduce elements
            for (int i = 0; i < array->size; i++) {
                if (array->is_string_array) {
                    // For string arrays, reduce by length sum or count
                    const char* str_elem = (const char*)array->str_elements[i];
                    if (str_elem) {
                        if (operation == 0) {
                            accumulator += strlen(str_elem); // sum of lengths
                        } else if (operation == 1) {
                            accumulator += 1; // count
                        }
                    }
                } else {
                    // For number arrays, apply mathematical reduction
                    long long elem = array->elements[i];
                    if (operation == 0) {
                        accumulator += elem; // sum
                    } else if (operation == 1) {
                        accumulator *= elem; // product
                    } else if (operation == 2) {
                        accumulator = (accumulator > elem) ? accumulator : elem; // max
                    } else if (operation == 3) {
                        accumulator = (accumulator < elem) ? accumulator : elem; // min
                    }
                }
            }
            
            return accumulator;
        } else if (func_name && strcmp(func_name, "to_string") == 0) {
            // to_string(value) - convert any value to string
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: to_string() function requires one argument\n");
                return 0;
            }
            
            long long value = eval_expression(&ast->children[1].children[0]);
            // to_string - input value: %lld\n", value);
            if (error_occurred) return 0;
            
            char* result_str = NULL;
            if (value == -1) {
                // Already a string - get its value
                ASTNode* arg_node = &ast->children[1].children[0];
                if (arg_node->type == AST_EXPR && arg_node->text) {
                    const char* str_val = get_str_value(arg_node->text);
                    if (str_val) {
                        result_str = tracked_strdup(str_val, __FILE__, __LINE__, "eval");
                    }
                }
            } else if (value == -2) {
                // Array - convert to string representation
                ASTNode* arg_node = &ast->children[1].children[0];
                if (arg_node->type == AST_EXPR && arg_node->text) {
                    MycoArray* array = get_array_value(arg_node->text);
                    if (array) {
                        result_str = tracked_malloc(256, __FILE__, __LINE__, "eval");
                        if (result_str) {
                            strcpy(result_str, "[");
                            for (int i = 0; i < array->size; i++) {
                                if (i > 0) strcat(result_str, ", ");
                                if (array->is_string_array) {
                                    const char* str_val = array_get_string(array, i);
                                    if (str_val) {
                                        strcat(result_str, "\"");
                                        strcat(result_str, str_val);
                                        strcat(result_str, "\"");
                                    }
            } else {
                                    long long* num_val = (long long*)array_get(array, i);
                                    if (num_val) {
                                        char num_str[32];
                                        snprintf(num_str, sizeof(num_str), "%lld", *num_val);
                                        strcat(result_str, num_str);
                                    }
                                }
                            }
                            strcat(result_str, "]");
                        }
                    }
                }
            } else if (value == -3) {
                // Object - convert to string representation
                ASTNode* arg_node = &ast->children[1].children[0];
                if (arg_node->type == AST_EXPR && arg_node->text) {
                    MycoObject* obj = get_object_value(arg_node->text);
                    if (obj) {
                        result_str = tracked_malloc(256, __FILE__, __LINE__, "eval");
                        if (result_str) {
                            strcpy(result_str, "{");
                            for (int i = 0; i < obj->property_count; i++) {
                                if (i > 0) strcat(result_str, ", ");
                                if (obj->property_names[i]) {
                                    strcat(result_str, obj->property_names[i]);
                                    strcat(result_str, ": ");
                                    // For now, just show property names
                                    strcat(result_str, "?");
                                }
                            }
                            strcat(result_str, "}");
                        }
                    }
                }
            } else {
                // Numeric value - convert to string
                result_str = tracked_malloc(32, __FILE__, __LINE__, "eval");
                if (result_str) {
                    snprintf(result_str, 32, "%lld", value);
                }
            }
            
            // to_string - result_str: %s\n", result_str ? result_str : "(null)");
            if (result_str) {
                // Store the result string in a predictable variable name
                set_str_value("__last_tostring_result", result_str);
                // to_string - storing in: __last_tostring_result\n");
                // to_string - returning -1\n");
                return -1; // Indicate string result
            }
            // to_string - returning 0 (failure)\n");
            return 0;
        } else if (func_name && strcmp(func_name, "first") == 0) {
            // first(array) - get first element without removing
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: first() function requires one argument\n");
                return 0;
            }
            
            ASTNode* array_node = &ast->children[1].children[0];
            if (array_node->type == AST_EXPR && array_node->text) {
                // Extract the actual variable name from the string literal
                const char* array_name = array_node->text;
                if (is_string_literal(array_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(array_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, array_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            array_name = temp_name;
                        }
                    }
                }
                
                MycoArray* array = get_array_value(array_name);
                if (array && array->size > 0) {
                    if (array->is_string_array) {
                        // For string arrays, return the first string
                        const char* first_str = array_get_string(array, 0);
                        if (first_str) {
                                                    // Store the result string in a temporary variable

                        // Store the result string in a temporary variable
                        set_str_value("__last_first_result", strdup(first_str));
                        // Clear other results to avoid conflicts
                        set_str_value("__last_last_result", "");
                        set_str_value("__last_tostring_result", "");
                        set_str_value("__last_pop_result", "");
                        return -1; // Indicate string result
                        }
            } else {
                        // For numeric arrays, return the first number
                        long long* first_num = (long long*)array_get(array, 0);
                        if (first_num) {
                            return *first_num;
                        }
                    }
                }
            }
            return 0;
        } else if (func_name && strcmp(func_name, "reverse") == 0) {

            // reverse(array) - reverse the order of array elements
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: reverse() function requires one argument\n");
                return 0;
            }
            
            ASTNode* array_node = &ast->children[1].children[0];
            if (array_node->type == AST_EXPR && array_node->text) {
                // Extract the actual variable name from the string literal
                const char* array_name = array_node->text;
                if (is_string_literal(array_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(array_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, array_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            array_name = temp_name;
                        }
                    }
                }
                
                MycoArray* array = get_array_value(array_name);
                if (array && array->size > 1) {
                    // Reverse the array in place
                    if (array->is_string_array) {
                        // For string arrays, reverse string elements
                        for (int i = 0; i < array->size / 2; i++) {
                            char* temp = array->str_elements[i];
                            array->str_elements[i] = array->str_elements[array->size - 1 - i];
                            array->str_elements[array->size - 1 - i] = temp;
                        }
            } else {
                        // For numeric arrays, reverse numeric elements
                        for (int i = 0; i < array->size / 2; i++) {
                            long long* temp = (long long*)array_get(array, i);
                            long long* temp2 = (long long*)array_get(array, array->size - 1 - i);
                            if (temp && temp2) {
                                long long swap = *temp;
                                *temp = *temp2;
                                *temp2 = swap;
                            }
                        }
                    }
                    return 0; // Success
                } else if (array && array->size <= 1) {
                    // Array is already "reversed" if it has 0 or 1 elements
                    return 0; // Success
                }
            }
            return 0;
        } else if (func_name && strcmp(func_name, "last") == 0) {
            // last(array) - get last element without removing
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: last() function requires one argument\n");
                return 0;
            }
            
            ASTNode* array_node = &ast->children[1].children[0];
            if (array_node->type == AST_EXPR && array_node->text) {
                // Extract the actual variable name from the string literal
                const char* array_name = array_node->text;
                if (is_string_literal(array_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(array_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, array_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            array_name = temp_name;
                        }
                    }
                }
                
                MycoArray* array = get_array_value(array_name);
                if (array && array->size > 0) {
                    if (array->is_string_array) {
                        // For string arrays, return the last string
                        const char* last_str = array_get_string(array, array->size - 1);
                        if (last_str) {
                                                    // Store the result string in a temporary variable

                        // Store the result string in a temporary variable
                        set_str_value("__last_last_result", strdup(last_str));
                        // Clear other results to avoid conflicts
                        set_str_value("__last_first_result", "");
                        set_str_value("__last_tostring_result", "");
                        set_str_value("__last_pop_result", "");
                        return -1; // Indicate string result
                        }
            } else {
                        // For numeric arrays, return the last number
                        long long* last_num = (long long*)array_get(array, array->size - 1);
                        if (last_num) {
                            return *last_num;
            }
                    }
                }
            }
            return 0;
        }
        
        // MATH LIBRARY FUNCTIONS v1.3.0
        // ===============================
        
        // Mathematical constants
        if (func_name && strcmp(func_name, "PI") == 0) {
            return (long long)(MYCO_PI * 1000000); // Return as integer * 1M for precision
        } else if (func_name && strcmp(func_name, "E") == 0) {
            return (long long)(MYCO_E * 1000000); // Return as integer * 1M for precision
        } else if (func_name && strcmp(func_name, "INF") == 0) {
            return 999999999; // Large number to represent infinity
        } else if (func_name && strcmp(func_name, "NAN") == 0) {
            return -999999999; // Special value to represent NaN
        }
        
        // Basic mathematical functions
        else if (func_name && strcmp(func_name, "abs") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: abs() function requires one argument\n");
                return 0;
            }
            
            // Check if the argument is a float literal
            ASTNode* arg = &ast->children[1].children[0];
            if (arg->text && strchr(arg->text, '.') != NULL) {
                // Float literal
                double float_val = strtod(arg->text, NULL);
                double result = fabs(float_val);
                last_result_is_float = 1;
                return (long long)(result * 1000000);
            } else if (arg->text) {
                // Check if it's a float variable
                for (int i = var_env_size - 1; i >= 0; i--) {
                    if (var_env[i].name && strcmp(var_env[i].name, arg->text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                        double result = fabs(var_env[i].float_value);
                        last_result_is_float = 1;
                        return (long long)(result * 1000000);
                    }
                }
            }
            
            // Handle as integer
            long long value = eval_expression(arg);
            last_result_is_float = 0;
            return value < 0 ? -value : value;
        }
        
        else if (func_name && strcmp(func_name, "pow") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: pow() function requires two arguments\n");
                return 0;
            }
            
            // Check if either argument is a float
            ASTNode* base_arg = &ast->children[1].children[0];
            ASTNode* exp_arg = &ast->children[1].children[1];
            
            double base_val = 0.0, exp_val = 0.0;
            int base_is_float = 0, exp_is_float = 0;
            
            // Check base argument
            if (base_arg->text && strchr(base_arg->text, '.') != NULL) {
                base_is_float = 1;
                base_val = strtod(base_arg->text, NULL);
            } else if (base_arg->text) {
                for (int i = var_env_size - 1; i >= 0; i--) {
                    if (var_env[i].name && strcmp(var_env[i].name, base_arg->text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                        base_is_float = 1;
                        base_val = var_env[i].float_value;
                        break;
                    }
                }
                if (!base_is_float) {
                    long long base_int = eval_expression(base_arg);
                    base_val = (double)base_int;
                }
            } else {
                long long base_int = eval_expression(base_arg);
                base_val = (double)base_int;
            }
            
            // Check exponent argument
            if (exp_arg->text && strchr(exp_arg->text, '.') != NULL) {
                exp_is_float = 1;
                exp_val = strtod(exp_arg->text, NULL);
            } else if (exp_arg->text) {
                for (int i = var_env_size - 1; i >= 0; i--) {
                    if (var_env[i].name && strcmp(var_env[i].name, exp_arg->text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                        exp_is_float = 1;
                        exp_val = var_env[i].float_value;
                        break;
                    }
                }
                if (!exp_is_float) {
                    long long exp_int = eval_expression(exp_arg);
                    exp_val = (double)exp_int;
                }
            } else {
                long long exp_int = eval_expression(exp_arg);
                exp_val = (double)exp_int;
            }
            
            if (base_is_float || exp_is_float) {
                // Use floating-point pow function
                double result = pow(base_val, exp_val);
                last_result_is_float = 1;
                return (long long)(result * 1000000);
            } else {
                // Integer-only operation (original logic)
                long long base = (long long)base_val;
                long long exponent = (long long)exp_val;
                if (exponent < 0) {
                    fprintf(stderr, "Error: pow() with negative exponent not yet supported for integers\n");
                    return 0;
                }
                long long result = 1;
                for (int i = 0; i < exponent; i++) {
                    result *= base;
                }
                last_result_is_float = 0;
                return result;
            }
        }
        
        else if (func_name && strcmp(func_name, "sqrt") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: sqrt() function requires one argument\n");
                return 0;
            }
            
            // Check if the argument is a float literal or variable
            ASTNode* arg = &ast->children[1].children[0];
            if (arg->text && strchr(arg->text, '.') != NULL) {
                // Float literal
                double float_val = strtod(arg->text, NULL);
                if (float_val < 0) {
                    fprintf(stderr, "Error: sqrt() of negative number not supported\n");
                    return 0;
                }
                double result = sqrt(float_val);
                last_result_is_float = 1;
                return (long long)(result * 1000000);
            } else if (arg->text) {
                // Check if it's a float variable
                for (int i = var_env_size - 1; i >= 0; i--) {
                    if (var_env[i].name && strcmp(var_env[i].name, arg->text) == 0 && var_env[i].type == VAR_TYPE_FLOAT) {
                        if (var_env[i].float_value < 0) {
                            fprintf(stderr, "Error: sqrt() of negative number not supported\n");
                            return 0;
                        }
                        double result = sqrt(var_env[i].float_value);
                        last_result_is_float = 1;
                        return (long long)(result * 1000000);
                    }
                }
            }
            
            // Handle as integer
            long long value = eval_expression(arg);
            if (value < 0) {
                fprintf(stderr, "Error: sqrt() of negative number not supported\n");
                return 0;
            }
            // Simple integer square root approximation
            long long result = 0;
            while (result * result <= value) {
                result++;
            }
            last_result_is_float = 0;
            return result - 1;
        }
        
        else if (func_name && strcmp(func_name, "floor") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: floor() function requires one argument\n");
                return 0;
            }
            long long value = eval_expression(&ast->children[1].children[0]);
            return value; // For integers, floor is the same as the value
        }
        
        else if (func_name && strcmp(func_name, "ceil") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: ceil() function requires one argument\n");
                return 0;
            }
            long long value = eval_expression(&ast->children[1].children[0]);
            return value; // For integers, ceil is the same as the value
        }
        
        else if (func_name && strcmp(func_name, "min") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: min() function requires at least one argument\n");
                return 0;
            }
            
            // Check if any argument is a float
            int any_float = 0;
            for (int i = 0; i < ast->children[1].child_count; i++) {
                ASTNode* arg = &ast->children[1].children[i];
                if (arg->text && strchr(arg->text, '.') != NULL) {
                    any_float = 1;
                    break;
                } else if (arg->text) {
                    for (int j = var_env_size - 1; j >= 0; j--) {
                        if (var_env[j].name && strcmp(var_env[j].name, arg->text) == 0 && var_env[j].type == VAR_TYPE_FLOAT) {
                            any_float = 1;
                            break;
                        }
                    }
                    if (any_float) break;
                }
            }
            
            if (any_float) {
                // Float comparison
                double min_val = DBL_MAX;
                for (int i = 0; i < ast->children[1].child_count; i++) {
                    ASTNode* arg = &ast->children[1].children[i];
                    double val = 0.0;
                    
                    if (arg->text && strchr(arg->text, '.') != NULL) {
                        val = strtod(arg->text, NULL);
                    } else if (arg->text) {
                        int found_float = 0;
                        for (int j = var_env_size - 1; j >= 0; j--) {
                            if (var_env[j].name && strcmp(var_env[j].name, arg->text) == 0 && var_env[j].type == VAR_TYPE_FLOAT) {
                                val = var_env[j].float_value;
                                found_float = 1;
                                break;
                            }
                        }
                        if (!found_float) {
                            long long int_val = eval_expression(arg);
                            val = (double)int_val;
                        }
            } else {
                        long long int_val = eval_expression(arg);
                        val = (double)int_val;
                    }
                    
                    if (i == 0 || val < min_val) {
                        min_val = val;
                    }
                }
                last_result_is_float = 1;
                return (long long)(min_val * 1000000);
            } else {
                // Integer comparison
                long long min_val = eval_expression(&ast->children[1].children[0]);
                for (int i = 1; i < ast->children[1].child_count; i++) {
                    long long val = eval_expression(&ast->children[1].children[i]);
                    if (val < min_val) min_val = val;
                }
                last_result_is_float = 0;
                return min_val;
            }
        }
        
        else if (func_name && strcmp(func_name, "max") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: max() function requires at least one argument\n");
                return 0;
            }
            
            // Check if any argument is a float
            int any_float = 0;
            for (int i = 0; i < ast->children[1].child_count; i++) {
                ASTNode* arg = &ast->children[1].children[i];
                if (arg->text && strchr(arg->text, '.') != NULL) {
                    any_float = 1;
                    break;
                } else if (arg->text) {
                    for (int j = var_env_size - 1; j >= 0; j--) {
                        if (var_env[j].name && strcmp(var_env[j].name, arg->text) == 0 && var_env[j].type == VAR_TYPE_FLOAT) {
                            any_float = 1;
                            break;
                        }
                    }
                    if (any_float) break;
                }
            }
            
            if (any_float) {
                // Float comparison
                double max_val = -DBL_MAX;
                for (int i = 0; i < ast->children[1].child_count; i++) {
                    ASTNode* arg = &ast->children[1].children[i];
                    double val = 0.0;
                    
                    if (arg->text && strchr(arg->text, '.') != NULL) {
                        val = strtod(arg->text, NULL);
                    } else if (arg->text) {
                        int found_float = 0;
                        for (int j = var_env_size - 1; j >= 0; j--) {
                            if (var_env[j].name && strcmp(var_env[j].name, arg->text) == 0 && var_env[j].type == VAR_TYPE_FLOAT) {
                                val = var_env[j].float_value;
                                found_float = 1;
                                break;
                            }
                        }
                        if (!found_float) {
                            long long int_val = eval_expression(arg);
                            val = (double)int_val;
                        }
                    } else {
                        long long int_val = eval_expression(arg);
                        val = (double)int_val;
                    }
                    
                    if (i == 0 || val > max_val) {
                        max_val = val;
                    }
                }
                last_result_is_float = 1;
                return (long long)(max_val * 1000000);
            } else {
                // Integer comparison
                long long max_val = eval_expression(&ast->children[1].children[0]);
                for (int i = 1; i < ast->children[1].child_count; i++) {
                    long long val = eval_expression(&ast->children[1].children[i]);
                    if (val > max_val) max_val = val;
                }
                last_result_is_float = 0;
                return max_val;
            }
        }
        
        // Random number generation
        else if (func_name && strcmp(func_name, "random") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count > 0) {
                fprintf(stderr, "Error: random() function takes no arguments\n");
                return 0;
            }
            return (long long)(myco_random() * 1000000); // Return as integer * 1M for precision
        }
        
        else if (func_name && strcmp(func_name, "randint") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: randint() function requires two arguments (min, max)\n");
                return 0;
            }
            long long min_val = eval_expression(&ast->children[1].children[0]);
            long long max_val = eval_expression(&ast->children[1].children[1]);
            return myco_randint(min_val, max_val);
        }
        
        else if (func_name && strcmp(func_name, "choice") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: choice() function requires one argument (array)\n");
                return 0;
            }
            // For now, return a simple random choice
            // TODO: Implement proper array choice functionality
            return myco_randint(1, 100);
        }
        
        // UTILITY LIBRARY FUNCTIONS v1.3.2
        // =================================
        
        // Pretty-printing and debugging functions
        else if (func_name && strcmp(func_name, "debug") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: debug() function requires one argument\n");
                return 0;
            }
            
            // Get the value to debug
            long long value = eval_expression(&ast->children[1].children[0]);
            if (error_occurred) return 0;
            
            // Enhanced debug output with type information
            printf("DEBUG: ");
            if (value == -1) {
                // String value
                ASTNode* arg_node = &ast->children[1].children[0];
                if (arg_node->type == AST_EXPR && arg_node->text) {
                    const char* str_val = get_str_value(arg_node->text);
                    if (str_val) {
                        printf("string = \"%s\" (length: %zu)", str_val, strlen(str_val));
            } else {
                        printf("string = \"\" (empty)");
                    }
                }
            } else if (value == -2) {
                // Array value
                printf("array (use len() to get size)");
            } else if (value == -3) {
                // Object value
                printf("object (use object_keys() to get properties)");
            } else {
                // Numeric value
                printf("number = %lld", value);
            }
            printf("\n");
            return 1;
        }
        
        // Type checking functions
        else if (func_name && strcmp(func_name, "type") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: type() function requires one argument\n");
                return 0;
            }
            
            // Get the value to check
            ASTNode* arg_node = &ast->children[1].children[0];
            long long value = eval_expression(arg_node);
            if (error_occurred) return 0;
            
            // Store the type name in a predictable variable for print function to access
            const char* type_name = NULL;
            
            // Check for string literals first (they return 1 from eval_expression)
            if (arg_node->text && arg_node->text[0] == '"') {
                type_name = "String";
            }
            // Check for array literals (they are AST_ARRAY_LITERAL nodes)
            else if (arg_node->type == AST_ARRAY_LITERAL) {
                type_name = "Array";
            }
            // Check for object literals (they are AST_OBJECT_LITERAL nodes)
            else if (arg_node->type == AST_OBJECT_LITERAL) {
                type_name = "Object";
            }
            // Return type name for variables: -1=string, -2=array, -3=object, >=0=number
            else if (value == -1) {
                type_name = "String";
            } else if (value == -2) {
                type_name = "Array";
            } else if (value == -3) {
                type_name = "Object";
            } else {
                type_name = "Integer";
            }
            
            // Store the type name in a global variable for the print function
            if (last_concat_result) {
                tracked_free(last_concat_result, __FILE__, __LINE__, "eval");
            }
            last_concat_result = tracked_strdup(type_name, __FILE__, __LINE__, "eval");
            
            // Return -1 to indicate this is a string result
            return -1;
        }
        
        else if (func_name && strcmp(func_name, "is_num") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: is_num() function requires one argument\n");
                return 0;
            }
            
            long long value = eval_expression(&ast->children[1].children[0]);
            if (error_occurred) return 0;
            
            // Return 1 if numeric (>= 0), 0 otherwise
            return (value >= 0) ? 1 : 0;
        }
        
        else if (func_name && strcmp(func_name, "is_str") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: is_str() function requires one argument\n");
                return 0;
            }
            
            ASTNode* arg_node = &ast->children[1].children[0];
            long long value = eval_expression(arg_node);
            if (error_occurred) return 0;
            
            // Check for string literals first (they start with quote)
            if (arg_node->text && arg_node->text[0] == '"') {
                return 1; // String literal
            }
            
            // Return 1 if string variable (-1), 0 otherwise
            return (value == -1) ? 1 : 0;
        }
        
        else if (func_name && strcmp(func_name, "is_arr") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: is_arr() function requires one argument\n");
                return 0;
            }
            
            ASTNode* arg_node = &ast->children[1].children[0];
            long long value = eval_expression(arg_node);
            if (error_occurred) return 0;
            
            // Check for array literals first (they are AST_ARRAY_LITERAL nodes)
            if (arg_node->type == AST_ARRAY_LITERAL) {
                return 1; // Array literal
            }
            
            // Return 1 if array variable (-2), 0 otherwise
            return (value == -2) ? 1 : 0;
        }
        
        else if (func_name && strcmp(func_name, "is_obj") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: is_obj() function requires one argument\n");
                return 0;
            }
            
            ASTNode* arg_node = &ast->children[1].children[0];
            long long value = eval_expression(arg_node);
            if (error_occurred) return 0;
            
            // Check for object literals first (they are AST_OBJECT_LITERAL nodes)
            if (arg_node->type == AST_OBJECT_LITERAL) {
                return 1; // Object literal
            }
            
            // Return 1 if object variable (-3), 0 otherwise
            return (value == -3) ? 1 : 0;
        }
        
        // String utility functions
        else if (func_name && strcmp(func_name, "str") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: str() function requires one argument\n");
                return 0;
            }
            
            // str() is an alias for to_string()
            return eval_expression(&ast->children[1].children[0]);
        }
        
        else if (func_name && strcmp(func_name, "find") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: find() function requires two arguments (string, substring)\n");
                return 0;
            }
            
            // Get the main string
            ASTNode* str_node = &ast->children[1].children[0];
            const char* main_str = NULL;
            long long str_result = eval_expression(str_node);
            
            if (str_result == -1) {
                // String variable
                main_str = get_str_value(str_node->text);
            } else if (str_result == 1) {
                // String literal
                if (str_node->text && str_node->text[0] == '"') {
                    size_t len = strlen(str_node->text);
                    if (len >= 2) {
                        char* temp_str = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "find_string");
                        strncpy(temp_str, str_node->text + 1, len - 2);
                        temp_str[len - 2] = '\0';
                        main_str = temp_str;
                    }
                }
            }
            
            // Get the substring to search for
            ASTNode* sub_node = &ast->children[1].children[1];
            const char* sub_str = NULL;
            long long sub_result = eval_expression(sub_node);
            
            if (sub_result == -1) {
                // String variable
                sub_str = get_str_value(sub_node->text);
            } else if (sub_result == 1) {
                // String literal
                if (sub_node->text && sub_node->text[0] == '"') {
                    size_t len = strlen(sub_node->text);
                    if (len >= 2) {
                        char* temp_str = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "find_substring");
                        strncpy(temp_str, sub_node->text + 1, len - 2);
                        temp_str[len - 2] = '\0';
                        sub_str = temp_str;
                    }
                }
            }
            
            if (!main_str || !sub_str) {
                fprintf(stderr, "Error: find() requires string arguments\n");
                return -1;
            }
            
            // Find the substring position
            char* found = strstr(main_str, sub_str);
            if (found) {
                return (long long)(found - main_str);
            } else {
                return -1; // Not found
            }
        }
        
        // Data utility functions
        else if (func_name && strcmp(func_name, "copy") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 1) {
                fprintf(stderr, "Error: copy() function requires one argument\n");
                return 0;
            }
            
            // For now, return the value directly (shallow copy)
            // TODO: Implement deep copy for arrays and objects
            return eval_expression(&ast->children[1].children[0]);
        }
        
        else if (func_name && strcmp(func_name, "has") == 0) {
            if (ast->child_count < 2 || ast->children[1].child_count < 2) {
                fprintf(stderr, "Error: has() function requires two arguments (object, key)\n");
                return 0;
            }
            
            // Get the object name (same pattern as has_key)
            ASTNode* obj_node = &ast->children[1].children[0];
            const char* obj_name = NULL;
            if (obj_node->type == AST_EXPR && obj_node->text) {
                obj_name = obj_node->text;
                if (is_string_literal(obj_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(obj_name);
                    if (len >= 2) {
                        char* temp_name = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_name) {
                            strncpy(temp_name, obj_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            obj_name = temp_name;
                        }
                    }
                }
            }
            
            // Get the key to check (same pattern as has_key)
            ASTNode* key_node = &ast->children[1].children[1];
            const char* key_name = NULL;
            if (key_node->type == AST_EXPR && key_node->text) {
                key_name = key_node->text;
                if (is_string_literal(key_name)) {
                    // Remove quotes from the string literal
                    size_t len = strlen(key_name);
                    if (len >= 2) {
                        char* temp_key = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_key) {
                            strncpy(temp_key, key_name + 1, len - 2);
                            temp_key[len - 2] = '\0';
                            key_name = temp_key;
                        }
                    }
                }
            }
            
            if (!obj_name || !key_name) {
                fprintf(stderr, "Error: has() requires valid object and key names\n");
                return 0;
            }
            
            // Check if the object has the key
            MycoObject* obj = get_object_value(obj_name);
            if (obj) {
                for (int i = 0; i < obj->property_count; i++) {
                    if (obj->property_names[i] && strcmp(obj->property_names[i], key_name) == 0) {
                        return 1; // Key exists
                    }
                }
            }
            return 0; // Key doesn't exist
        }
    }
    
    // Handle dot expressions (method calls) first
    if (ast->type == AST_DOT) {
        if (ast->child_count >= 2) {
            // Left side is the object (string variable name)
            ASTNode* obj_node = &ast->children[0];
            const char* obj_name = NULL;
            
            if (obj_node->type == AST_EXPR && obj_node->text) {
                obj_name = obj_node->text;
            }
            
            if (!obj_name) return 0;
            
            // Right side is the method name
            ASTNode* method_node = &ast->children[1];
            const char* method_name = NULL;
            
            if (method_node->type == AST_EXPR && method_node->text) {
                method_name = method_node->text;
            }
            
            if (!method_name) return 0;
            
            // First, check if this is a module function call
            for (int i = 0; i < modules_size; i++) {
                if (strcmp(modules[i].alias, obj_name) == 0) {
                    // Found the module, now look for the function
                ASTNode* func = find_function_in_module(modules[i].module_ast, method_name);
                if (func) {
                    // Return a special value to indicate this is a module function call
                    // The actual call will be handled by the function call logic
                    return 1; // Success indicator
                } else {
                    return 0;
                }
                }
            }
            
            // Check if this is a library constant access (e.g., m.PI, m.E)
            const char* actual_library = get_library_alias(obj_name);
            if (actual_library) {
                if (strcmp(actual_library, "math") == 0) {
                    if (strcmp(method_name, "PI") == 0) {
                        return (long long)(3.141592653589793 * 1000000);
                    } else if (strcmp(method_name, "E") == 0) {
                        return (long long)(2.718281828459045 * 1000000);
                    } else if (strcmp(method_name, "INF") == 0) {
                        return 999999999;
                    } else if (strcmp(method_name, "NAN") == 0) {
                        return -999999999;
                    }
                }
                // For now, return 0 for unknown constants (will be handled by function calls)
                return 0;
            }
            
            // If not a module, handle as string methods
            const char* str_val = get_str_value(obj_name);
            if (!str_val) str_val = "";
            
            // Handle different string methods
            if (strcmp(method_name, "join") == 0) {
                // .join(separator) - returns the string itself (no-op for single strings)
                return 0; // Just return success
            } else if (strcmp(method_name, "split") == 0) {
                // .split(separator) - for now just return success
                // TODO: Implement actual splitting logic
                return 0;
            } else if (strcmp(method_name, "length") == 0) {
                // .length - return string length
                return (int)strlen(str_val);
            } else if (strcmp(method_name, "upper") == 0) {
                // .upper() - convert to uppercase
                if (str_val && *str_val) {
                    char* upper = tracked_strdup(str_val, __FILE__, __LINE__, "eval");
                    if (upper) {
                        for (int i = 0; upper[i]; i++) {
                            upper[i] = toupper(upper[i]);
                        }
                        set_str_value(obj_name, upper);
                        free(upper);
                    }
                }
                return 0;
            } else if (strcmp(method_name, "lower") == 0) {
                // .lower() - convert to lowercase
                if (str_val && *str_val) {
                    char* lower = tracked_strdup(str_val, __FILE__, __LINE__, "eval");
                    if (lower) {
                        for (int i = 0; lower[i]; i++) {
                            lower[i] = tolower(lower[i]);
                        }
                        set_str_value(obj_name, lower);
                        free(lower);
                    }
                }
                return 0;
            } else if (strcmp(method_name, "trim") == 0) {
                // .trim() - remove leading/trailing whitespace
                if (str_val && *str_val) {
                    char* trimmed = tracked_strdup(str_val, __FILE__, __LINE__, "eval");
                    if (trimmed) {
                        char* start = trimmed;
                        char* end = trimmed + strlen(trimmed) - 1;
                        
                        // Skip leading whitespace
                        while (*start && isspace(*start)) start++;
                        
                        // Skip trailing whitespace
                        while (end > start && isspace(*end)) end--;
                        
                        *(end + 1) = '\0';
                        
                        if (start > trimmed) {
                            memmove(trimmed, start, strlen(start) + 1);
                        }
                        
                        set_str_value(obj_name, trimmed);
                        free(trimmed);
                    }
                }
                return 0;
            }
        }
        return 0;
    }

    if (ast->type == AST_EXPR && ast->text) {
        
        // Check if this is a variable reference
        if (var_exists(ast->text)) {
            long long value = get_var_value(ast->text);
            if (value == -2) {
                // This is an array variable - return special value to indicate it's an array
                return -2; // Special value to indicate array variable
            } else if (value == -3) {
                // This is an object variable - return special value to indicate it's an object
                return -3; // Special value to indicate object variable
            }
                    return value;
        } else {
            // Check if this is a string variable
            const char* str_val = get_str_value(ast->text);
            if (str_val) {
                // This is a string variable - return a special value to indicate it's a string
                // We'll handle the actual string display in the print function
                return -1; // Special value to indicate string variable
            }
        }
        
        // Check if this is a string literal
        if (is_string_literal(ast->text)) {
            return 1; // Return 1 to indicate string
        }
        
        // Check if this is a number
        char* endptr;
        long long num = strtoll(ast->text, &endptr, 10);
        if (*endptr == '\0') {
            return num;
        }
    }
    
    return 0;
}

// Main evaluation function
void eval_evaluate(ASTNode* ast) {
    if (!ast) return;



    switch (ast->type) {
        case AST_FOR: {
            // Initialize loop execution state if not already done
            if (!global_loop_state) {
                init_loop_execution_state();
            }

            // Get loop components
            if (ast->child_count < 3) {
                fprintf(stderr, "Error: Invalid for loop structure\n");
                return;
            }

            // Extract loop variable name from first child
            char* loop_var_name = ast->children[0].text;
            if (!loop_var_name) {
                fprintf(stderr, "Error: Loop variable name is NULL\n");
                return;
            }

            // Evaluate start, end, and step values
            int64_t start = eval_expression(&ast->children[1]);
            int64_t end = eval_expression(&ast->children[2]);
            
            // Check if we have a step parameter by looking at the structure
            // For loops without step: [loop_var, start, end, body] (4 children)
            // For loops with step: [loop_var, start, end, step, body] (5 children)
            int64_t step = 1; // Default step
            if (ast->child_count == 5) {
                // Loop has explicit step
                step = eval_expression(&ast->children[3]);
            }

            // Create and push loop context
            LoopContext* context = create_loop_context(loop_var_name, start, end, step, ast->line);
            if (!context) {
                fprintf(stderr, "Error: Failed to create loop context\n");
                return;
            }

            push_loop_context(global_loop_state, context);
            global_loop_state->in_loop_body = 1;

            // Execute loop
            int iterations = 0;
            while (should_continue_loop(context)) {
                // Set loop variable value
                set_var_value(loop_var_name, context->current_value);

                // Execute loop body
                if (ast->child_count == 5) {
                    // Loop with step: body is at children[4]
                    eval_evaluate(&ast->children[4]);
                } else {
                    // Loop without step: body is at children[3]
                    eval_evaluate(&ast->children[3]);
                }

                // Check for control flow
                if (global_loop_state->break_requested) {
                    global_loop_state->break_requested = 0;
            break;
        }
                if (global_loop_state->continue_requested) {
                    global_loop_state->continue_requested = 0;
                    continue;
                }
                if (global_loop_state->return_requested) {
                    break;
                }

                // Update loop state
                context->current_value += context->step_value;
                context->iteration_count++;
                iterations++;

                // Safety check
                if (iterations > MAX_LOOP_ITERATIONS) {
                    fprintf(stderr, "Error: Maximum loop iterations exceeded at line %d\n", ast->line);
                    break;
                }
            }

            // Clean up
            global_loop_state->in_loop_body = 0;
            LoopContext* popped = pop_loop_context(global_loop_state);
            if (popped) {
                destroy_loop_context(popped);
            }

            // Update statistics
            update_loop_statistics(1, iterations, 0);

            return;
        }

        case AST_LAMBDA: {
            // Lambda functions are stored as variables and evaluated when called
            // Store the lambda AST for later execution
            if (ast->child_count >= 2) {
                // For now, we'll store them with a special name
                // In the next phase, we'll implement proper variable binding
                char* lambda_id = tracked_strdup("lambda", __FILE__, __LINE__, "eval_lambda");
                set_lambda_value(lambda_id, ast);
                
                // Clean up temporary ID
                tracked_free(lambda_id, __FILE__, __LINE__, "eval_lambda_cleanup");
            }
            return;
        }

        case AST_WHILE: {
            if (ast->child_count < 2) {
                fprintf(stderr, "Error: Invalid while loop structure\n");
                return;
            }

            int iterations = 0;
            while (1) {
            // Evaluate condition
                int64_t condition_result = eval_expression(&ast->children[0]);
                
                if (!condition_result) {
                    break; // Condition is false
                }

                // Execute loop body
                eval_evaluate(&ast->children[1]);

                // Check for control flow
                if (global_loop_state && global_loop_state->break_requested) {
                    global_loop_state->break_requested = 0;
            break;
        }
                if (global_loop_state && global_loop_state->continue_requested) {
                    global_loop_state->continue_requested = 0;
                    continue;
                }
                if (global_loop_state && global_loop_state->return_requested) {
            break;
        }

                iterations++;

                // Safety check
                if (iterations > MAX_LOOP_ITERATIONS) {
                    fprintf(stderr, "Error: Maximum while loop iterations exceeded at line %d\n", ast->line);
                        break;
                    }
            }

            return;
        }

        case AST_BLOCK: {
            // Handle special block types
            if (ast->text && strcmp(ast->text, "use") == 0 && ast->child_count == 2) {
                // This is a 'use' statement: import library or load module
                char* library_name = ast->children[0].text;
                char* alias = ast->children[1].text;
                
        
                
                // Check if this is a built-in library
                if (strcmp(library_name, "math") == 0 || 
                    strcmp(library_name, "util") == 0 || 
                    strcmp(library_name, "core") == 0 ||
                    strcmp(library_name, "file_io") == 0 ||
                    strcmp(library_name, "path_utils") == 0 ||
                    strcmp(library_name, "env") == 0 ||
                    strcmp(library_name, "args") == 0 ||
                    strcmp(library_name, "process") == 0 ||
                    strcmp(library_name, "text_utils") == 0 ||
                    strcmp(library_name, "debug") == 0) {
                    // Import built-in library
        
                    add_library_import(library_name, alias);
                } else {
                    // Load and parse the module
                    printf("DEBUG: Attempting to load module '%s'\n", library_name);
                    ASTNode* module_ast = load_and_parse_module(library_name);
                    if (module_ast) {
                        // Register the module with the alias
                        register_module(alias, module_ast);
                    } else {
                        fprintf(stderr, "Error: Failed to load module '%s'\n", library_name);
                    }
                }
            } else {
                // Regular block - evaluate all children
                for (int i = 0; i < ast->child_count; i++) {
                    eval_evaluate(&ast->children[i]);
                    // Check if a return statement was encountered
                    if (return_flag) {
            break;
        }
                }
            }
            return;
        }

        case AST_PRINT: {
            // Reset float flag to prevent interference from previous operations
            last_result_is_float = 0;
            
            if (ast->child_count == 0) {
                printf("\n");
                return;
            }

            for (int i = 0; i < ast->child_count; i++) {
                if (i > 0) printf(" ");
                
                ASTNode* arg = &ast->children[i];
                if (arg->type == AST_EXPR) {
                    if (arg->text && arg->text[0] == '"') {
                        // String literal - print without quotes
                        size_t len = strlen(arg->text);
                        if (len > 2) {
                            // Print the string content between quotes
                            printf("%.*s", (int)(len-2), arg->text + 1);
                        }
                    } else {
                        // Variable or number (AST_EXPR)
                        int64_t value = eval_expression(arg);
                        if (value == -999) {
                            // Already printed, skip further processing
                            // Do nothing - value was already output by eval_expression
                        } else if (value == -1) {
                            // This is a string variable or concatenation result - get and print the actual string value

                            const char* str_val = NULL;
                            if (last_concat_result) {
                                // This is the result of a string concatenation

                                str_val = last_concat_result;
                            } else if (arg->text) {
                                // This is a string variable

                                str_val = get_str_value(arg->text);

                            } else {
                                // This might be a function call result - look for predictable result variables

                                // Check for replace() function result first
                                str_val = get_str_value("__last_replace_result");

                                if (!str_val) {
                                    // Check for trim() function result
                                    str_val = get_str_value("__last_trim_result");

                                }
                                if (!str_val) {
                                    // Check for join() function result
                                    str_val = get_str_value("__last_join_result");

                                }
                                if (!str_val) {
                                    str_val = get_str_value("__last_tostring_result");

                                }

                                if (!str_val) {
                                    // Check for first() function result
                                    str_val = get_str_value("__last_first_result");

                                }
                                if (!str_val) {
                                    // Check for last() function result
                                    str_val = get_str_value("__last_last_result");

                                }
                                if (!str_val) {
                                    // Check for pop() function result
                                    str_val = get_str_value("__last_pop_result");

                                }
                            }
                            
                            if (str_val) {
                                printf("%s", str_val);
                            } else {
                                printf("(null)");
                            }
                        } else if (value == -2) {
                            // This is an array variable - get and print the array contents

                            MycoArray* array = NULL;
                            if (arg->text) {
                                // Direct variable reference
                                array = get_array_value(arg->text);

                            } else {
                                // This might be a function call result - look for predictable result variables
                                // Check most recent functions first
                                array = get_array_value("__last_values_result");
                                if (array) {

                                } else {
                                    array = get_array_value("__last_split_result");
                                    if (array) {

                                    } else {
                                        array = get_array_value("__last_slice_result");
                                        if (array) {

                                        } else {
                                            array = get_array_value("__last_object_keys_result");
                                            if (array) {

                                            } else {

                                            }
                                        }
                                    }
                                }
                            }
                            
                            if (array) {
                                printf("[");
                                for (int j = 0; j < array->size; j++) {
                                    if (j > 0) printf(", ");
                                    if (array->is_string_array) {
                                        char* str_elem = (char*)array_get(array, j);
                                        if (str_elem) {
                                            printf("\"%s\"", str_elem);
                                        } else {
                                            printf("(null)");
                                        }
                                    } else {
                                        long long* num_elem = (long long*)array_get(array, j);
                                        if (num_elem) {
                                            printf("%lld", *num_elem);
                                        } else {
                                            printf("(null)");
                                        }
                                    }
                                }
                                printf("]");
                            } else {
                                printf("(null)");
                            }
                        } else if (value == -3) {
                            // This is an object variable - get and print the object contents
                            if (arg->text) {
                                MycoObject* obj = get_object_value(arg->text);
                            if (obj) {
                                    printf("{");
                                    for (int j = 0; j < obj->property_count; j++) {
                                        if (j > 0) printf(", ");
                                        printf("%s: ", obj->property_names[j]);
                                        
                                        // Use type-based printing instead of heuristics
                                        void* prop_value = obj->property_values[j];
                                        PropertyType prop_type = obj->property_types[j];
                                        print_property_value(prop_value, prop_type);
                                    }
                                    printf("}");
                                } else {
                                    printf("(null)");
                                }
                            } else {
                                printf("(null)");
                            }
                        } else {
                            // Check if this value might be a scaled float
                            if (arg->text && strchr(arg->text, '.') != NULL) {
                                // This is a float literal, unscale and display as float
                                double float_val = (double)value / 1000000.0;
                                printf("%.6g", float_val);
                            } else if (last_result_is_float) {
                                // This is the result of a float arithmetic operation
                                double float_val = (double)value / 1000000.0;
                                printf("%.6g", float_val);
                                last_result_is_float = 0; // Reset flag after use
                            } else {
                                // Check if this is a variable containing a float
                                const char* var_name = arg->text;
                                int is_float_var = 0;
                                if (var_name) {
                                    // Check if this variable is stored as a float
                                    for (int i = var_env_size - 1; i >= 0; i--) {
                                        if (var_env[i].name && strcmp(var_env[i].name, var_name) == 0) {
                                            if (var_env[i].type == VAR_TYPE_FLOAT) {
                                                printf("%.6g", var_env[i].float_value);
                                                is_float_var = 1;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (!is_float_var) {
                                    // This is a normal numeric value - print it directly
                                    printf("%lld", (long long)value);
                                }
                            }
                        }
                    }
                } else if (arg->type == AST_DOT) {
                    // Check if this is a library constant first
                    if (arg->child_count >= 2 &&
                        arg->children[0].type == AST_EXPR && arg->children[0].text &&
                        arg->children[1].type == AST_EXPR && arg->children[1].text) {
                        
                        const char* alias = arg->children[0].text;
                        const char* constant_name = arg->children[1].text;
                        const char* actual_library = get_library_alias(alias);
                        
                        if (actual_library) {
                            // This is a library alias - handle constants
                            if (strcmp(actual_library, "math") == 0) {
                                if (strcmp(constant_name, "PI") == 0) {
                                    printf("3.14159");
                                    continue;
                                } else if (strcmp(constant_name, "E") == 0) {
                                    printf("2.71828");
                                    continue;
                                } else if (strcmp(constant_name, "INF") == 0) {
                                    printf("inf");
                                    continue;
                                } else if (strcmp(constant_name, "NAN") == 0) {
                                    printf("nan");
                                    continue;
                                }
                            }
                        }
                    }
                    
                    // If not a library constant, handle as object property access
                    PropertyType prop_type;
                    void* prop_value = evaluate_chained_property_for_print(arg, &prop_type);
                    
                    if (prop_value) {
                        print_property_value(prop_value, prop_type);
                    } else {
                        printf("0"); // Property not found or evaluation failed
                    }
                } else {
                    // Handle other node types by evaluating them
                    int64_t value = eval_expression(arg);
                    if (value == -1) {
                        // This is a string variable or concatenation result - get and print the actual string value
                        if (last_concat_result) {
                            // This is the result of a string concatenation
                            printf("%s", last_concat_result);
                        } else if (arg->text) {
                            // This is a string variable
                            const char* str_val = get_str_value(arg->text);
                            if (str_val) {
                                printf("%s", str_val);
                            } else {
                                printf("(null)");
                            }
                        } else {
                            printf("(null)");
                        }
                    } else if (value == -2) {
                        // This is an array variable - get and print the array contents
                        if (arg->text) {
                            MycoArray* array = get_array_value(arg->text);
                            if (array) {
                                printf("[");
                                for (int j = 0; j < array->size; j++) {
                                    if (j > 0) printf(", ");
                                    if (array->is_string_array) {
                                        char* str_elem = (char*)array_get(array, j);
                                        if (str_elem) {
                                            printf("\"%s\"", str_elem);
                                        } else {
                                            printf("(null)");
                                        }
                                    } else {
                                        long long* num_elem = (long long*)array_get(array, j);
                                        if (num_elem) {
                                            printf("%lld", *num_elem);
                                        } else {
                                            printf("(null)");
                                        }
                                    }
                                }
                                printf("]");
                            } else {
                                printf("(null)");
                            }
                        } else {
                            printf("(null)");
                        }
                    } else if (value == -3) {
                        // This is an object variable - get and print the object contents
                        if (arg->text) {
                            MycoObject* obj = get_object_value(arg->text);
                            if (obj) {
                                printf("{");
                                for (int j = 0; j < obj->property_count; j++) {
                                    if (j > 0) printf(", ");
                                    printf("%s: ", obj->property_names[j]);
                                    
                                    // Use type-based printing instead of heuristics
                                    void* prop_value = obj->property_values[j];
                                    PropertyType prop_type = obj->property_types[j];
                                    print_property_value(prop_value, prop_type);
                                }
                                printf("}");
                            } else {
                                printf("(null)");
                            }
                        } else {
                            printf("(null)");
                        }
                    } else if (value != -999) {
                        // Check if this value might be a scaled float
                        if (arg->text && strchr(arg->text, '.') != NULL) {
                            // This is a float literal, unscale and display as float
                            double float_val = (double)value / 1000000.0;
                            printf("%.6g", float_val);
                        } else if (last_result_is_float) {
                            // This is the result of a float arithmetic operation
                            double float_val = (double)value / 1000000.0;
                            printf("%.6g", float_val);
                            last_result_is_float = 0; // Reset flag after use
                        } else {
                            // Check if this is a variable containing a float
                            const char* var_name = arg->text;
                            int is_float_var = 0;
                            if (var_name) {
                                // Check if this variable is stored as a float
                                for (int i = var_env_size - 1; i >= 0; i--) {
                                    if (var_env[i].name && strcmp(var_env[i].name, var_name) == 0) {
                                        if (var_env[i].type == VAR_TYPE_FLOAT) {
                                            printf("%.6g", var_env[i].float_value);
                                            is_float_var = 1;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!is_float_var) {
                                // This is a normal numeric value - print it directly
                                printf("%lld", (long long)value);
                            }
                        }
                    }
                }
            }
            printf("\n");
            return;
        }



        case AST_EXPR: {
            if (!ast->text) return;

            // Check if this is an expression statement (text="expr_stmt" with children)
            if (ast->text && strcmp(ast->text, "expr_stmt") == 0 && ast->child_count >= 1) {
                // Evaluate the expression inside the statement
                eval_expression(&ast->children[0]);
                return;
            }

            // Check if this is a method call (text="call" with children)
            if (ast->text && strcmp(ast->text, "call") == 0 && ast->child_count >= 2) {
                // Get function name from first child
                ASTNode* func_name_node = &ast->children[0];
                
                // Check if the function name is a dot expression (obj.method)
                if (func_name_node->type == AST_DOT && func_name_node->child_count >= 2) {
                    // This is a method call: obj.method()
                    
                    
                    // Get object name and method name
                    char* obj_name = NULL;
                    char* method_name = NULL;
                    
                    if (func_name_node->children[0].type == AST_EXPR && func_name_node->children[0].text) {
                        obj_name = func_name_node->children[0].text;
                    }
                    if (func_name_node->children[1].type == AST_EXPR && func_name_node->children[1].text) {
                        method_name = func_name_node->children[1].text;
                    }
                    
                    
                    if (obj_name && method_name) {
                        // Get the object
                        MycoObject* obj = get_object_value(obj_name);
                        if (obj) {
                            // Get the method property
                            void* method_prop = object_get_property(obj, method_name);
                            if (method_prop) {
                                // Check if it's a method (for now, just check if it's "method")
                                char* method_value = (char*)method_prop;
                                if (method_value && strcmp(method_value, "method") == 0) {
                                    // This is a method - execute it
            
                                    // TODO: Implement actual method execution
                                    // For now, just print a message
                                    printf("Method '%s' called on object '%s'\n", method_name, obj_name);
                                } else {
                                    fprintf(stderr, "Error: Property '%s' is not a method at line %d\n", method_name, ast->line);
                                }
                            } else {
                                fprintf(stderr, "Error: Method '%s' not found in object '%s' at line %d\n", method_name, obj_name, ast->line);
                            }
                        } else {
                            fprintf(stderr, "Error: Object '%s' not found at line %d\n", obj_name, ast->line);
                        }
                    } else {
                        fprintf(stderr, "Error: Invalid method call syntax at line %d\n", ast->line);
                    }
                    return;
                }
                
                // This is a regular function call - evaluate it using eval_expression
                eval_expression(ast);
                return;
            }

            // Check if it's a variable
            if (var_exists(ast->text)) {
                get_var_value(ast->text);
                return;
            }



            // Check if it's a number
            char* endptr;
            long long num = strtoll(ast->text, &endptr, 10);
            if (*endptr == '\0') {
                return; // Number parsed successfully
            }

            // Check if it's an operator that should trigger implicit function calls
            if (strcmp(ast->text, "+") == 0 || strcmp(ast->text, "-") == 0 ||
                strcmp(ast->text, "*") == 0 || strcmp(ast->text, "/") == 0 ||
                strcmp(ast->text, "%") == 0 || strcmp(ast->text, "==") == 0 ||
                strcmp(ast->text, "!=") == 0 || strcmp(ast->text, "<") == 0 ||
                strcmp(ast->text, ">") == 0 || strcmp(ast->text, "<=") == 0 ||
                strcmp(ast->text, ">=") == 0 || strcmp(ast->text, "and") == 0 ||
                strcmp(ast->text, "or") == 0 || strcmp(ast->text, "in") == 0) {
                
                // This is an operator - check if we should call an implicit function
                if (ast->child_count >= 2) {
                    // Determine types of left and right operands
                    int left_type = VAR_TYPE_NUMBER;  // Default to number
                    int right_type = VAR_TYPE_NUMBER;
                    
                    // Check if left operand is a variable
                    if (ast->children[0].type == AST_EXPR && ast->children[0].text) {
                        if (var_exists(ast->children[0].text)) {
                            // Get variable type (simplified for now)
                            left_type = VAR_TYPE_NUMBER;  // Default assumption
                        }
                    }
                    
                    // Check if right operand is a variable
                    if (ast->children[1].type == AST_EXPR && ast->children[1].text) {
                        if (var_exists(ast->children[1].text)) {
                            // Get variable type (simplified for now)
                            right_type = VAR_TYPE_NUMBER;  // Default assumption
                        }
                    }
                    
                    // Get the appropriate implicit function
                    char* function_name = get_implicit_function(ast->text, left_type, right_type);
                    if (function_name) {
                        // Call the implicit function
                        long long result = call_implicit_function(function_name, ast->children, ast->child_count);
                        // Store result in a predictable location for assignment
                        set_var_value("__implicit_result", result);
                        return;
                    }
                }
                
                return; // Operator nodes should not be evaluated directly
            }

            return;
        }

        case AST_LET: {
            if (ast->child_count < 2) {
                fprintf(stderr, "Error: Invalid let statement structure\n");
                return;
            }

            char* var_name = ast->children[0].text;
            if (!var_name) {
                fprintf(stderr, "Error: Variable name is NULL\n");
                return;
            }

            // Check if the value is an array literal
            if (ast->children[1].type == AST_ARRAY_LITERAL) {
                // Handle array literal creation
                if (ast->children[1].child_count == 0) {
                    // Empty array
                    MycoArray* array = create_array(8, 0); // Default capacity, numeric array
                    if (!array) {
                        fprintf(stderr, "Error: Failed to create array at line %d\n", ast->line);
                        return;
                    }
                    set_array_value(var_name, array);
                    return;
                }
                
                // Determine if this is a string array by checking the first element
                int is_string_array = 0;
                if (ast->children[1].children[0].type == AST_EXPR && ast->children[1].children[0].text && is_string_literal(ast->children[1].children[0].text)) {
                    is_string_array = 1;
                }
                
                // Create array with appropriate capacity
                MycoArray* array = create_array(ast->children[1].child_count, is_string_array);
                if (!array) {
                    fprintf(stderr, "Error: Failed to create array at line %d\n", ast->line);
                    return;
                }
                
                // Add elements to the array
                for (int i = 0; i < ast->children[1].child_count; i++) {
                    if (is_string_array) {
                        // Handle string elements
                        if (ast->children[1].children[i].type == AST_EXPR && ast->children[1].children[i].text && is_string_literal(ast->children[1].children[i].text)) {
                            // Extract string value (remove quotes)
                            size_t len = strlen(ast->children[1].children[i].text);
                            if (len >= 2) {
                                char* value = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "eval_remaining_malloc");
                                if (value) {
                                    strncpy(value, ast->children[1].children[i].text + 1, len - 2);
                                    value[len - 2] = '\0';
                                    array_push(array, value);
                                    free(value);
                                }
                            }
                        } else {
                            // Convert non-string to string
                            char temp_str[64];
                            snprintf(temp_str, sizeof(temp_str), "%lld", eval_expression(&ast->children[1].children[i]));
                            array_push(array, temp_str);
                        }
                    } else {
                        // Handle numeric elements
                        long long value = eval_expression(&ast->children[1].children[i]);
                        // Store the actual value, not a pointer to local variable
                        array->elements[array->size] = value;
                        array->size++;
                    }
                }
                
                set_array_value(var_name, array);
                return;
            }
            
            // Check if the value is an array access
            if (ast->children[1].type == AST_ARRAY_ACCESS) {
                // Handle array access: let x = arr[index]
                if (ast->children[1].child_count < 2) {
                    fprintf(stderr, "Error: Invalid array access structure at line %d\n", ast->line);
                    return;
                }
                
                // Get the array name
                char* array_name = NULL;
                if (ast->children[1].children[0].type == AST_EXPR && ast->children[1].children[0].text) {
                    array_name = ast->children[1].children[0].text;
                } else {
                    fprintf(stderr, "Error: Invalid array expression at line %d\n", ast->line);
                    return;
                }
                
                // Get the array variable
                MycoArray* array = get_array_value(array_name);
                if (!array) {
                    fprintf(stderr, "Error: Array '%s' not found at line %d\n", array_name, ast->line);
                    return;
                }
                
                // Evaluate the index expression
                long long index = eval_expression(&ast->children[1].children[1]);
                
                if (index < 0 || index >= array->size) {
                    fprintf(stderr, "Error: Array index %lld out of bounds [0, %d] at line %d\n", 
                            index, array->size - 1, ast->line);
                    return;
                }
                
                // Get the element value and assign it to the variable
                void* element = array_get(array, index);
                if (!element) {
                    fprintf(stderr, "Error: Failed to access array element at line %d\n", ast->line);
                    return;
                }
                
                if (array->is_string_array) {
                    set_str_value(var_name, (char*)element);
                } else {
                    long long num_value = *(long long*)element;
                    set_var_value(var_name, num_value);
                }
                return;
            }
            
            // Check if the value is an object literal
            if (ast->children[1].type == AST_OBJECT_LITERAL) {
                // Handle object literal creation: let obj = {prop1: val1, prop2: val2}
                if (ast->children[1].child_count == 0) {
                    // Empty object
                    MycoObject* obj = create_object(8); // Default capacity
                    if (!obj) {
                        fprintf(stderr, "Error: Failed to create object at line %d\n", ast->line);
                        return;
                    }
                    set_object_value(var_name, obj);
                    return;
                }
                
                // Create object with appropriate capacity
                MycoObject* obj = create_object(ast->children[1].child_count);
                if (!obj) {
                    fprintf(stderr, "Error: Failed to create object at line %d\n", ast->line);
                    return;
                }
                
                // Add properties to the object
                for (int i = 0; i < ast->children[1].child_count; i++) {
                    if (ast->children[1].children[i].type == AST_EXPR && 
                        ast->children[1].children[i].text && 
                        strcmp(ast->children[1].children[i].text, "prop") == 0 &&
                        ast->children[1].children[i].child_count == 2) {
                        
                        // Get property name and value
                        char* prop_name = ast->children[1].children[i].children[0].text;
                        if (!prop_name) continue;
                        
                        // Check if the property value is a nested object literal
                        if (ast->children[1].children[i].children[1].type == AST_OBJECT_LITERAL) {
                            // This is a nested object: use recursive helper function
                            MycoObject* nested_obj = create_object_from_literal(&ast->children[1].children[i].children[1]);
                            if (nested_obj) {
                                object_set_property_typed(obj, prop_name, nested_obj, PROP_TYPE_OBJECT);
                            } else {
                                fprintf(stderr, "Error: Failed to create nested object at line %d\n", ast->line);
                                object_set_property_typed(obj, prop_name, (void*)0, PROP_TYPE_NUMBER);
                            }
                        } else {
                            // Check if the property value is a string literal
                            if (ast->children[1].children[i].children[1].type == AST_EXPR && 
                                ast->children[1].children[i].children[1].text &&
                                ast->children[1].children[i].children[1].text[0] == '"') {
                                // This is a string literal like "John"
                                // Store the string directly (remove quotes)
                                char* str_value = ast->children[1].children[i].children[1].text;
                                if (strlen(str_value) >= 2) {
                                    // Remove quotes and store the string
                                    char* clean_str = tracked_strdup(str_value + 1, __FILE__, __LINE__, "eval"); // Skip first quote
                                    clean_str[strlen(clean_str) - 1] = '\0'; // Remove last quote
                                    object_set_property_typed(obj, prop_name, clean_str, PROP_TYPE_STRING);
                                } else {
                                    // Empty string
                                    object_set_property_typed(obj, prop_name, strdup(""), PROP_TYPE_STRING);
                                }
                            } else {
                                // Evaluate the property value as a simple expression (number)
                                long long prop_value = eval_expression(&ast->children[1].children[i].children[1]);
                                
                                // Store the property as a number
                                object_set_property_typed(obj, prop_name, (void*)(long long)prop_value, PROP_TYPE_NUMBER);
                            }
                        }
                    }
                }
                
                set_object_value(var_name, obj);
                return;
            }
            
            // Check if the value is a lambda function
            if (ast->children[1].type == AST_LAMBDA) {
                // Store the lambda function in the variable environment
                set_lambda_value(var_name, &ast->children[1]);
                return;
            }
            
            // Handle regular numeric assignment
            int64_t value = eval_expression(&ast->children[1]);
            
            // Check if this is a float literal assignment
            if (ast->children[1].type == AST_EXPR && ast->children[1].text && strchr(ast->children[1].text, '.') != NULL) {
                // This is a float literal assignment - store as float
                char* endptr;
                double float_val = strtod(ast->children[1].text, &endptr);
                if (*endptr == '\0') {
                    set_float_value(var_name, float_val);
                    return;
                }
            }
            
            // Check if this is actually a string literal assignment
            if (ast->children[1].type == AST_EXPR && ast->children[1].text && is_string_literal(ast->children[1].text)) {
                // This is a string literal assignment - store in string environment
                size_t len = strlen(ast->children[1].text);
                if (len >= 2) {
                    char* clean_str = tracked_strdup(ast->children[1].text + 1, __FILE__, __LINE__, "eval"); // Skip first quote
                    clean_str[len - 2] = '\0'; // Remove last quote
                    set_str_value(var_name, clean_str);
                    free(clean_str);
                } else {
                    set_str_value(var_name, "");
                }
            } else if (value == -1) {
                // This is a string concatenation result or string function result
                if (last_concat_result) {
                    // String concatenation result
                    set_str_value(var_name, last_concat_result);
                } else {
                    // String function result - check all possible string function results
                    const char* str_result = get_str_value("__last_replace_result");
                    if (str_result) {
                        set_str_value(var_name, strdup(str_result));
                    } else {
                        // Check for trim() function result 
                        str_result = get_str_value("__last_trim_result");
                        if (str_result) {
                            set_str_value(var_name, strdup(str_result));
                        } else {
                            // Check for join() function result 
                            str_result = get_str_value("__last_join_result");
                            if (str_result) {
                                set_str_value(var_name, strdup(str_result));
                            } else {
                                // Check for first() function result 
                                str_result = get_str_value("__last_first_result");
                                if (str_result && strlen(str_result) > 0) {
                                    set_str_value(var_name, strdup(str_result));
                                } else {
                                    // Check for last() function result
                                    str_result = get_str_value("__last_last_result");
                                    if (str_result && strlen(str_result) > 0) {
                                        set_str_value(var_name, strdup(str_result));
                                    } else {
                                        // Check for pop() function result
                                        str_result = get_str_value("__last_pop_result");
                                        if (str_result && strlen(str_result) > 0) {
                                            set_str_value(var_name, strdup(str_result));
                                        } else {
                                            // Check for to_string result
                                            str_result = get_str_value("__last_tostring_result");
                                            if (str_result && strlen(str_result) > 0) {
                                                set_str_value(var_name, strdup(str_result));
                                            } else {
                                                set_str_value(var_name, "");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (value == -2) {
                // This is an array function result - get from predictable variable
                // Check most recent functions first (map is usually called after filter)
                MycoArray* array_result = get_array_value("__last_map_result");
                if (array_result) {
                    set_array_value(var_name, array_result);
                    return;
                }
                
                array_result = get_array_value("__last_filter_result");
                if (array_result) {
                    set_array_value(var_name, array_result);
                    return;
                }
                
                array_result = get_array_value("__last_values_result");
                if (array_result) {
                    set_array_value(var_name, array_result);
                } else {
                    array_result = get_array_value("__last_split_result");
                    if (array_result) {
                        set_array_value(var_name, array_result);
                    } else {
                        array_result = get_array_value("__last_slice_result");
                        if (array_result) {
                            set_array_value(var_name, array_result);
                        } else {
                            array_result = get_array_value("__last_object_keys_result");
                            if (array_result) {
                                set_array_value(var_name, array_result);
                            } else {
                                // Check if this is an array variable assignment (let x = existing_array)
                                // Look for the variable name in the expression
                                if (ast->children[1].type == AST_EXPR && ast->children[1].text) {
                                    MycoArray* existing_array = get_array_value(ast->children[1].text);
                                    if (existing_array) {
                                        // This is an array variable assignment - copy the array
                                        set_array_value(var_name, existing_array);
                                        return;
                                    }
                                }
                                // Fallback: create empty array
                                MycoArray* empty_array = create_array(1, 0);
                                set_array_value(var_name, empty_array);
                            }
                        }
                    }
                }
            } else {
                // This is a numeric assignment
            set_var_value(var_name, value);
            }
            return;
        }

        case AST_ASSIGN: {
            if (ast->child_count < 2) {
                fprintf(stderr, "Error: Invalid assignment statement structure\n");
                return;
            }

            char* var_name = ast->children[0].text;
            if (!var_name) {
                fprintf(stderr, "Error: Variable name is NULL\n");
                return;
            }

            int64_t value = eval_expression(&ast->children[1]);
            set_var_value(var_name, value);
            return;
        }

        case AST_OBJECT_ASSIGN: {
            if (ast->child_count < 3) {
                fprintf(stderr, "Error: Invalid object assignment structure\n");
                return;
            }

            if (ast->child_count == 3) {
                // Simple assignment: obj.prop = value
            char* obj_name = ast->children[0].text;
            char* prop_name = ast->children[1].text;
            if (!obj_name || !prop_name) {
                fprintf(stderr, "Error: Object or property name is NULL at line %d\n", ast->line);
                return;
            }

            // Get the object variable
            MycoObject* obj = get_object_value(obj_name);
            if (!obj) {
                fprintf(stderr, "Error: Object '%s' not found at line %d\n", obj_name, ast->line);
                return;
            }

            // Evaluate the value expression
            long long value = eval_expression(&ast->children[2]);

            // Set the object property
            if (!object_set_property(obj, prop_name, (void*)(long long)value)) {
                fprintf(stderr, "Error: Failed to set object property at line %d\n", ast->line);
                return;
            }
            }
            else if (ast->child_count == 4) {
                // Nested assignment: obj.prop1.prop2 = value
                char* obj_name = ast->children[0].text;
                char* prop1_name = ast->children[1].text;
                char* prop2_name = ast->children[2].text;
                if (!obj_name || !prop1_name || !prop2_name) {
                    fprintf(stderr, "Error: Object or property names are NULL at line %d\n", ast->line);
                return;
            }

                // Get the root object
                MycoObject* root_obj = get_object_value(obj_name);
                if (!root_obj) {
                    fprintf(stderr, "Error: Object '%s' not found at line %d\n", obj_name, ast->line);
            return;
        }

                // Get the intermediate object (prop1)
                void* prop1_value = object_get_property(root_obj, prop1_name);
                PropertyType prop1_type = object_get_property_type(root_obj, prop1_name);
                
                if (prop1_type != PROP_TYPE_OBJECT) {
                    fprintf(stderr, "Error: Property '%s.%s' is not an object at line %d\n", 
                            obj_name, prop1_name, ast->line);
                    return;
                }

                MycoObject* intermediate_obj = (MycoObject*)prop1_value;
                if (!intermediate_obj) {
                    fprintf(stderr, "Error: Property '%s.%s' is NULL at line %d\n", 
                            obj_name, prop1_name, ast->line);
                    return;
                }

                // Evaluate the value expression
                long long value = eval_expression(&ast->children[3]);

                // Set the final property (prop2) on the intermediate object
                if (!object_set_property(intermediate_obj, prop2_name, (void*)(long long)value)) {
                    fprintf(stderr, "Error: Failed to set nested property '%s.%s.%s' at line %d\n", 
                            obj_name, prop1_name, prop2_name, ast->line);
                    return;
                }
            }
            else if (ast->child_count == 5) {
                // 4-level nested assignment: obj.prop1.prop2.prop3 = value
                char* obj_name = ast->children[0].text;
                char* prop1_name = ast->children[1].text;
                char* prop2_name = ast->children[2].text;
                char* prop3_name = ast->children[3].text;
                if (!obj_name || !prop1_name || !prop2_name || !prop3_name) {
                    fprintf(stderr, "Error: Object or property names are NULL at line %d\n", ast->line);
                    return;
                }

                // Get the root object
                MycoObject* root_obj = get_object_value(obj_name);
                if (!root_obj) {
                    fprintf(stderr, "Error: Object '%s' not found at line %d\n", obj_name, ast->line);
                    return;
                }

                // Get the first intermediate object (prop1)
                void* prop1_value = object_get_property(root_obj, prop1_name);
                PropertyType prop1_type = object_get_property_type(root_obj, prop1_name);
                
                if (prop1_type != PROP_TYPE_OBJECT) {
                    fprintf(stderr, "Error: Property '%s.%s' is not an object at line %d\n", 
                            obj_name, prop1_name, ast->line);
                    return;
                }

                MycoObject* intermediate1_obj = (MycoObject*)prop1_value;
                if (!intermediate1_obj) {
                    fprintf(stderr, "Error: Property '%s.%s' is NULL at line %d\n", 
                            obj_name, prop1_name, ast->line);
                    return;
                }

                // Get the second intermediate object (prop2)
                void* prop2_value = object_get_property(intermediate1_obj, prop2_name);
                PropertyType prop2_type = object_get_property_type(intermediate1_obj, prop2_name);
                
                if (prop2_type != PROP_TYPE_OBJECT) {
                    fprintf(stderr, "Error: Property '%s.%s.%s' is not an object at line %d\n", 
                            obj_name, prop1_name, prop2_name, ast->line);
                    return;
                }

                MycoObject* intermediate2_obj = (MycoObject*)prop2_value;
                if (!intermediate2_obj) {
                    fprintf(stderr, "Error: Property '%s.%s.%s' is NULL at line %d\n", 
                            obj_name, prop1_name, prop2_name, ast->line);
                    return;
                }

                // Evaluate the value expression
                long long value = eval_expression(&ast->children[4]);

                // Set the final property (prop3) on the second intermediate object
                if (!object_set_property(intermediate2_obj, prop3_name, (void*)(long long)value)) {
                    fprintf(stderr, "Error: Failed to set nested property '%s.%s.%s.%s' at line %d\n", 
                            obj_name, prop1_name, prop2_name, prop3_name, ast->line);
                    return;
                }
            }
            else {
                fprintf(stderr, "Error: Unsupported nested assignment depth (child_count=%d) at line %d\n", 
                        ast->child_count, ast->line);
                return;
            }

            return;
        }





        case AST_OBJECT_BRACKET_ASSIGN: {
            if (ast->child_count < 3) {
                fprintf(stderr, "Error: Invalid object bracket assignment structure\n");
                return;
            }

            char* obj_name = ast->children[0].text;
            if (!obj_name) {
                fprintf(stderr, "Error: Object name is NULL at line %d\n", ast->line);
                return;
            }

            // Get the object variable
            MycoObject* obj = get_object_value(obj_name);
            if (!obj) {
                fprintf(stderr, "Error: Object '%s' not found at line %d\n", obj_name, ast->line);
                return;
            }

            // Evaluate the key expression to get the property name
            const char* prop_name = NULL;
            ASTNode* key_expr = &ast->children[1];
            long long key_result = eval_expression(key_expr);
            
            if (key_result == 1) {
                // String literal - extract the key
                if (key_expr->text && is_string_literal(key_expr->text)) {
                    size_t len = strlen(key_expr->text);
                    if (len >= 2) {
                        char* temp_key = tracked_malloc(len - 1, __FILE__, __LINE__, "eval");
                        if (temp_key) {
                            strncpy(temp_key, key_expr->text + 1, len - 2);
                            temp_key[len - 2] = '\0';
                            prop_name = temp_key;
                        }
                    }
                }
            } else if (key_result == -1) {
                // String variable - get its value
                if (key_expr->text) {
                    prop_name = get_str_value(key_expr->text);
                }
            }

            if (!prop_name) {
                fprintf(stderr, "Error: Could not determine property name at line %d\n", ast->line);
                return;
            }

            // Evaluate the value expression
            long long value = eval_expression(&ast->children[2]);

            // Set the object property (simplified approach like existing AST_OBJECT_ASSIGN)
            if (!object_set_property(obj, prop_name, (void*)(long long)value)) {
                fprintf(stderr, "Error: Failed to set object property at line %d\n", ast->line);
                return;
            }
            break;
        }

        case AST_ARRAY_ASSIGN: {
            if (ast->child_count < 3) {
                fprintf(stderr, "Error: Invalid array assignment structure\n");
                return;
            }
            
            // Get the array name from the first child
            char* array_name = ast->children[0].text;
            if (!array_name) {
                fprintf(stderr, "Error: Array name is NULL\n");
                return;
            }
            

            
            // Get the array variable
            MycoArray* array = get_array_value(array_name);
            if (!array) {
                fprintf(stderr, "Error: Array '%s' not found at line %d\n", array_name, ast->line);
                return;
            }

            
            // Evaluate the index expression
            long long index = eval_expression(&ast->children[1]);

            if (index < 0 || index >= array->size) {
                fprintf(stderr, "Error: Array index %lld out of bounds [0, %d] at line %d\n", 
                        index, array->size - 1, ast->line);
                return;
            }
            
            // Evaluate the value expression
            long long value = eval_expression(&ast->children[2]);

            
            // Set the array element

            if (!array_set(array, index, &value)) {
                fprintf(stderr, "Error: Failed to set array element at line %d\n", ast->line);
                return;
            }

            
            return;
        }

        case AST_IF: {
            if (ast->child_count < 2) {
                fprintf(stderr, "Error: Invalid if statement structure\n");
                return;
            }

            int64_t condition = eval_expression(&ast->children[0]);
            if (condition) {
                eval_evaluate(&ast->children[1]);
            } else if (ast->child_count > 2) {
                eval_evaluate(&ast->children[2]);
            }
            return;
        }

        case AST_RETURN: {
            if (ast->child_count > 0) {
                int64_t value = eval_expression(&ast->children[0]);
                
                // Set global return values for function calls
                return_flag = 1;
                return_value = value;
                
                if (global_loop_state) {
                    global_loop_state->return_requested = 1;
                }
                return;
            }
            
            // Set global return values for function calls
            return_flag = 1;
            return_value = 0;
            
            if (global_loop_state) {
                global_loop_state->return_requested = 1;
            }
            return;
        }

        case AST_FUNC: {
            // Function definition - register it in the function registry
            if (ast->text && ast->child_count >= 2) {
                // Register the function for later calls
                register_function(ast->text, ast);
            }
            return;
        }

        case AST_SWITCH: {
            // Switch statement handling
            if (ast->child_count < 2) {
                fprintf(stderr, "Error: Invalid switch statement structure\n");
                return;
            }

            // Evaluate switch expression
            int64_t switch_value = eval_expression(&ast->children[0]);
            
            // Get cases block (second child)
            ASTNode* cases_block = &ast->children[1];
            if (cases_block->type != AST_BLOCK) {
                fprintf(stderr, "Error: Switch cases must be in a block\n");
                return;
            }

            // Look for matching case or default
            int case_matched = 0;
            int execute_remaining = 0; // For fall-through behavior
            
            for (int i = 0; i < cases_block->child_count; i++) {
                ASTNode* case_node = &cases_block->children[i];
                
                if (case_node->type == AST_CASE && case_node->child_count >= 2) {
                    // Evaluate case value
                    int64_t case_value = eval_expression(&case_node->children[0]);
                    
                    if (case_value == switch_value || execute_remaining) {
                        case_matched = 1;
                        execute_remaining = 1; // Enable fall-through
                        
                        // Execute case body - check if it's valid
                        if (case_node->children[1].type == AST_BLOCK && case_node->children[1].children) {
                            // Execute each statement in the case body
                            for (int j = 0; j < case_node->children[1].child_count; j++) {
                                eval_evaluate(&case_node->children[1].children[j]);
                            }
                        }
                        
                        // Check for break (in a real implementation, we'd need break handling)
                        // For now, we'll execute only the matching case
                        break;
                    }
                } else if (case_node->type == AST_DEFAULT && case_node->child_count >= 1) {
                    if (!case_matched || execute_remaining) {
                        // Execute default case - check if it's valid
                        if (case_node->children[0].type == AST_BLOCK && case_node->children[0].children) {
                            // Execute each statement in the default body
                            for (int j = 0; j < case_node->children[0].child_count; j++) {
                                eval_evaluate(&case_node->children[0].children[j]);
                            }
                        }
                        break;
                    }
                }
            }
            return;
        }

        case AST_TRY: {
            // Try/catch handling
            if (ast->child_count < 1) {
                fprintf(stderr, "Error: Invalid try statement structure\n");
                return;
            }

            // Save current error state and flags
            int saved_error_occurred = error_occurred;
            int saved_error_value = error_value;
            int saved_in_try_block = in_try_block;
            int saved_error_printed = error_printed;
            
            // Reset error state for try block
            error_occurred = 0;
            error_value = 0;
            in_try_block = 1;  // Set flag to suppress error printing
            error_printed = 0;

            // Execute try block
            eval_evaluate(&ast->children[0]);

            // Check if an error occurred during try block execution
            if (error_occurred && ast->child_count >= 3) {
                // Parser structure: [try_body, error_var, catch_body]
                // Child 1 is the error variable (AST_EXPR)
                // Child 2 is the catch body (AST_BLOCK)
                
                ASTNode* error_var = &ast->children[1];
                ASTNode* catch_body = &ast->children[2];
                
                // Set error variable if it has a name
                if (error_var->text) {
                    const char* error_desc = get_error_description(error_value);
                    set_str_value(error_var->text, error_desc);
                }
                
                // Execute catch block
                in_catch_block = 1;
                eval_evaluate(catch_body);
                in_catch_block = 0;
                // Clear error after handling
                error_occurred = 0;
                error_value = 0;
            }

            // Restore previous error state and flags
            in_try_block = saved_in_try_block;
            error_printed = saved_error_printed;
            if (!error_occurred) {
                error_occurred = saved_error_occurred;
                error_value = saved_error_value;
            }
            return;
        }

        case AST_DEFAULT: {
            // Default case - if we reach here directly, it means it's outside a switch
            // In many languages, this would be an error, but for robustness we'll just ignore it
            // The switch statement handler takes care of executing default cases properly
            return;
        }

        case AST_CASE: {
            // Case statement - this is handled by the switch statement itself
            // If we reach here directly, it's an error
            fprintf(stderr, "Error: Case statement outside of switch statement\n");
            return;
        }

        case AST_CATCH: {
            // Catch statement - this is handled by the try statement itself
            // If we reach here directly, it's an error
            fprintf(stderr, "Error: Catch statement outside of try statement\n");
            return;
        }

        default:
            fprintf(stderr, "Error: Unhandled AST node type: %d\n", ast->type);
            return;
    }
}

// Main evaluation function ends here

// Function to clear module AST references to prevent double-free
void eval_clear_module_asts() {
    if (modules && modules_size > 0) {
        for (int i = 0; i < modules_size; i++) {
            modules[i].module_ast = NULL;
        }
    }
}

// Function to clear function AST references to prevent double-free
void eval_clear_function_asts() {
    if (functions && functions_size > 0) {
        for (int i = 0; i < functions_size; i++) {
            functions[i].func_ast = NULL;
        }
    }
}



// Function to reset all environments for fresh execution
void eval_reset_environments() {
    cleanup_all_environments();
    
    // Reset scope stack
    if (scope_stack) {
        free(scope_stack);
        scope_stack = NULL;
    }
    scope_stack_size = 0;
    scope_stack_capacity = 0;
    
    // Reset error state
    error_occurred = 0;
    error_value = 0;
    current_line = 0;
    return_flag = 0;
    return_value = 0;
    in_try_block = 0;
    in_catch_block = 0;
    
    // Reset loop counter
    loop_counter = 0;
}

// Error handling with conditional compilation
static void print_error(const char* message, int line) {
    #if ENABLE_DETAILED_ERRORS
    char error_msg[512];
    snprintf(error_msg, sizeof(error_msg), "Line %d: %s", line, message);
    fprintf(stderr, "%s\n", error_msg);
    #else
    fprintf(stderr, "Error at line %d\n", line);
    #endif
}

    // Print function
static void eval_print(ASTNode* ast) {
    #if DEBUG_EVAL_TRACE
    
    #endif
    
        for (int i = 0; i < ast->child_count; i++) {
        ASTNode* child = &ast->children[i];
        
        // Check if it's a string literal (text starts with quote)
        if (child->text && child->text[0] == '"') {
            // Print string literal
            size_t len = strlen(child->text);
            if (len > 2) {
                printf("%.*s", (int)(len-2), child->text+1);
            }
        } else {
            // Print variable value
            const char* sv = get_str_value(child->text);
            if (sv) { 
                printf("%s", sv); 
                goto after_print_arg; 
            }
            
            // For non-string nodes, evaluate them
            eval_evaluate(child);
        }
        
        after_print_arg:
        if (i < ast->child_count - 1) {
            printf(" ");
        }
    }
    printf("\n");
} 

// Helper function to get an array variable from the environment
MycoArray* get_array_value(const char* name) {
    // Search from the end (most recent variables first) to prioritize function parameters
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (var_env[i].name && strcmp(var_env[i].name, name) == 0) {
            if (var_env[i].type == VAR_TYPE_ARRAY) {
                return var_env[i].array_value;
            }
            return NULL;
        }
    }
    return NULL;
} 

// ========================= SET MANAGEMENT FUNCTIONS =========================

int set_has(MycoSet* set, void* element) {
    if (!set || !element) return 0;
    
    for (int i = 0; i < set->element_count; i++) {
        if (set->is_string_set) {
            char* str_elem = (char*)set->elements[i];
            char* target_str = (char*)element;
            if (str_elem && target_str && strcmp(str_elem, target_str) == 0) {
                return 1;
            }
        } else {
            long long* num_elem = (long long*)set->elements[i];
            long long* target_num = (long long*)element;
            if (num_elem && target_num && *num_elem == *target_num) {
                return 1;
            }
        }
    }
    return 0;
}

int set_add(MycoSet* set, void* element) {
    if (!set || !element) return 0;
    
    // Check if element already exists (sets contain unique elements)
    if (set_has(set, element)) {
        return 1; // Element already exists, consider this success
    }
    
    // Expand capacity if needed
    if (set->element_count >= set->capacity) {
        int new_capacity = set->capacity * 2;
        void** new_elements = (void**)tracked_realloc(set->elements, 
            new_capacity * sizeof(void*), __FILE__, __LINE__, "set_add_expand");
        if (!new_elements) return 0;
        
        set->elements = new_elements;
        set->capacity = new_capacity;
    }
    
    // Add the element
    if (set->is_string_set) {
        set->elements[set->element_count] = tracked_strdup((char*)element, __FILE__, __LINE__, "eval");
    } else {
        long long* new_num = (long long*)tracked_malloc(sizeof(long long), __FILE__, __LINE__, "set_add_number");
        if (!new_num) return 0;
        *new_num = *(long long*)element;
        set->elements[set->element_count] = new_num;
    }
    
    set->element_count++;
    return 1;
}

int set_size(MycoSet* set) {
    return set ? set->element_count : 0;
}

void set_set_value(const char* name, MycoSet* set) {
    // Check if variable already exists
    for (int i = 0; i < var_env_size; i++) {
        if (var_env[i].name && strcmp(var_env[i].name, name) == 0) {
            var_env[i].type = VAR_TYPE_SET;
            var_env[i].set_value = set;
            return;
        }
    }
    
    // Add new variable
    if (var_env_size >= var_env_capacity) {
        int new_capacity = var_env_capacity == 0 ? 16 : var_env_capacity * 2;
        VarEntry* new_env = (VarEntry*)tracked_realloc(var_env, 
            new_capacity * sizeof(VarEntry), __FILE__, __LINE__, "expand_var_env_set");
        if (!new_env) return;
        
        var_env = new_env;
        var_env_capacity = new_capacity;
    }
    
    var_env[var_env_size].name = tracked_strdup(name, __FILE__, __LINE__, "eval");
    var_env[var_env_size].type = VAR_TYPE_SET;
    var_env[var_env_size].set_value = set;
    var_env_size++;
}

MycoSet* get_set_value(const char* name) {
    for (int i = var_env_size - 1; i >= 0; i--) {
        if (var_env[i].name && strcmp(var_env[i].name, name) == 0) {
            if (var_env[i].type == VAR_TYPE_SET) {
                return var_env[i].set_value;
            }
            return NULL;
        }
    }
    return NULL;
}

/*******************************************************************************
 * LIBRARY FUNCTION IMPLEMENTATIONS
 ******************************************************************************/

// Math Library Functions
static long long call_math_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "abs") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: math.abs() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        return value < 0 ? -value : value;
        
    } else if (strcmp(func_name, "pow") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: math.pow() requires two arguments\n");
            return 0;
        }
        
        long long base = eval_expression(&args_node->children[0]);
        long long exp = eval_expression(&args_node->children[1]);
        return (long long)pow((double)base, (double)exp);
        
    } else if (strcmp(func_name, "sqrt") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: math.sqrt() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        if (value < 0) {
            fprintf(stderr, "Error: math.sqrt() cannot take square root of negative number\n");
            return 0;
        }
        return (long long)sqrt((double)value);
        
    } else if (strcmp(func_name, "min") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: math.min() requires at least two arguments\n");
            return 0;
        }
        
        long long min_val = LLONG_MAX;
        for (int i = 0; i < args_node->child_count; i++) {
            long long value = eval_expression(&args_node->children[i]);
            if (value < min_val) min_val = value;
        }
        return min_val;
        
    } else if (strcmp(func_name, "max") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: math.max() requires at least two arguments\n");
            return 0;
        }
        
        long long max_val = LLONG_MIN;
        for (int i = 0; i < args_node->child_count; i++) {
            long long value = eval_expression(&args_node->children[i]);
            if (value > max_val) max_val = value;
        }
        return max_val;
        
    } else if (strcmp(func_name, "PI") == 0) {
        if (args_node->child_count == 0) {
            return (long long)(3.141592653589793 * 1000000);
        } else {
            fprintf(stderr, "Error: math.PI is a constant, not a function\n");
            return 0;
        }
        
    } else if (strcmp(func_name, "E") == 0) {
        if (args_node->child_count == 0) {
            return (long long)(2.718281828459045 * 1000000);
        } else {
            fprintf(stderr, "Error: math.E is a constant, not a function\n");
            return 0;
        }
        
    } else if (strcmp(func_name, "INF") == 0) {
        return 999999999;
        
    } else if (strcmp(func_name, "NAN") == 0) {
        return -999999999;
        
    } else if (strcmp(func_name, "floor") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: math.floor() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        return (long long)floor((double)value);
        
    } else if (strcmp(func_name, "ceil") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: math.ceil() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        return (long long)ceil((double)value);
        
    } else if (strcmp(func_name, "choice") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: math.choice() requires at least one argument\n");
            return 0;
        }
        
        // For now, just return the first argument
        // In a full implementation, this would randomly select from the arguments
        return eval_expression(&args_node->children[0]);
        
    } else {
        fprintf(stderr, "Error: Unknown math function '%s'\n", func_name);
        return 0;
    }
}

// Array Library Functions
static long long call_array_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "push") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: array.push() requires two arguments (array, value)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require modifying the array
        return 1;
        
    } else if (strcmp(func_name, "pop") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: array.pop() requires one argument (array)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require modifying the array
        return 0;
        
    } else if (strcmp(func_name, "length") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: array.length() requires one argument (array)\n");
            return 0;
        }
        
        // This is the same as len() function
        return call_core_function("len", args_node);
        
    } else if (strcmp(func_name, "get") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: array.get() requires two arguments (array, index)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require array access
        return 0;
        
    } else if (strcmp(func_name, "set") == 0) {
        if (args_node->child_count < 3) {
            fprintf(stderr, "Error: array.set() requires three arguments (array, index, value)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require modifying the array
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown array function '%s'\n", func_name);
        return 0;
    }
}

// Object Library Functions
static long long call_object_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "keys") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: object.keys() requires one argument (object)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require extracting object keys
        return 0;
        
    } else if (strcmp(func_name, "values") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: object.values() requires one argument (object)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require extracting object values
        return 0;
        
    } else if (strcmp(func_name, "has") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: object.has() requires two arguments (object, property)\n");
            return 0;
        }
        
        // This is the same as util.has() function
        return call_util_function("has", args_node);
        
    } else if (strcmp(func_name, "get") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: object.get() requires two arguments (object, property)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require object property access
        return 0;
        
    } else if (strcmp(func_name, "set") == 0) {
        if (args_node->child_count < 3) {
            fprintf(stderr, "Error: object.set() requires three arguments (object, property, value)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require modifying the object
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown object function '%s'\n", func_name);
        return 0;
    }
}

// Utility Library Functions
static long long call_util_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "debug") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.debug() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        printf("DEBUG: %lld\n", value);
        return 1;
        
    } else if (strcmp(func_name, "type") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.type() requires one argument\n");
            return 0;
        }
        
        ASTNode* arg = &args_node->children[0];
        
        if (arg->type == AST_ARRAY_LITERAL) {
            printf("Array");
        } else if (arg->type == AST_OBJECT_LITERAL) {
            printf("Object");
        } else if (arg->type == AST_EXPR && arg->text) {
            if (arg->text[0] == '"') {
                printf("String");
            } else if (strchr(arg->text, '.') != NULL) {
                printf("Float");
            } else {
                printf("Integer");
            }
        } else {
            printf("Unknown");
        }
        return 1;
        
    } else if (strcmp(func_name, "is_num") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.is_num() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        return (value >= 0) ? 1 : 0;
        
    } else if (strcmp(func_name, "is_str") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.is_str() requires one argument\n");
            return 0;
        }
        
        ASTNode* arg = &args_node->children[0];
        if (arg->type == AST_EXPR && arg->text && arg->text[0] == '"') {
            return 1;
        }
        return 0;
        
    } else if (strcmp(func_name, "is_arr") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.is_arr() requires one argument\n");
            return 0;
        }
        
        ASTNode* arg = &args_node->children[0];
        if (arg->type == AST_ARRAY_LITERAL) {
            return 1;
        }
        
        // Check if it's an array variable
        if (arg->type == AST_EXPR && arg->text) {
            MycoArray* array = get_array_value(arg->text);
            if (array) {
                return 1;
            }
        }
        return 0;
        
    } else if (strcmp(func_name, "is_obj") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.is_obj() requires one argument\n");
            return 0;
        }
        
        ASTNode* arg = &args_node->children[0];
        if (arg->type == AST_OBJECT_LITERAL) {
            return 1;
        }
        
        // Check if it's an object variable
        if (arg->type == AST_EXPR && arg->text) {
            MycoObject* obj = get_object_value(arg->text);
            if (obj) {
                return 1;
            }
        }
        return 0;
        
    } else if (strcmp(func_name, "find") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: util.find() requires two arguments (string, substring)\n");
            return 0;
        }
        
        // Get the string to search in
        ASTNode* str_node = &args_node->children[0];
        const char* str_val = NULL;
        
        if (str_node->type == AST_EXPR && str_node->text) {
            if (str_node->text[0] == '"') {
                // String literal
                size_t len = strlen(str_node->text);
                if (len > 2) {
                    char* temp = tracked_malloc(len - 1, __FILE__, __LINE__, "find_str_literal");
                    strncpy(temp, str_node->text + 1, len - 2);
                    temp[len - 2] = '\0';
                    str_val = temp;
                }
            } else {
                // String variable
                str_val = get_str_value(str_node->text);
            }
        }
        
        if (!str_val) {
            fprintf(stderr, "Error: util.find() first argument must be a string\n");
            return -1;
        }
        
        // Get the substring to search for
        ASTNode* substr_node = &args_node->children[1];
        const char* substr_val = NULL;
        
        if (substr_node->type == AST_EXPR && substr_node->text) {
            if (substr_node->text[0] == '"') {
                // String literal
                size_t len = strlen(substr_node->text);
                if (len > 2) {
                    char* temp = tracked_malloc(len - 1, __FILE__, __LINE__, "find_substr_literal");
                    strncpy(temp, substr_node->text + 1, len - 2);
                    temp[len - 2] = '\0';
                    substr_val = temp;
                }
            } else {
                // String variable
                substr_val = get_str_value(substr_node->text);
            }
        }
        
        if (!substr_val) {
            fprintf(stderr, "Error: util.find() second argument must be a string\n");
            return -1;
        }
        
        // Find the substring
        char* found = strstr(str_val, substr_val);
        if (found) {
            return (long long)(found - str_val);
        } else {
            return -1; // Not found
        }
        
    } else if (strcmp(func_name, "copy") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: util.copy() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        return value; // For now, just return the value (deep copy would need more complex logic)
        
    } else if (strcmp(func_name, "has") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: util.has() requires two arguments (object, property)\n");
            return 0;
        }
        
        // Get the object
        ASTNode* obj_node = &args_node->children[0];
        MycoObject* obj = NULL;
        
        if (obj_node->type == AST_OBJECT_LITERAL) {
            // Object literal - check if it has the property
            ASTNode* prop_node = &args_node->children[1];
            if (prop_node->type == AST_EXPR && prop_node->text) {
                const char* prop_name = prop_node->text;
                if (prop_name[0] == '"') {
                    // Remove quotes
                    size_t len = strlen(prop_name);
                    if (len > 2) {
                        char temp_name[256];
                        strncpy(temp_name, prop_name + 1, len - 2);
                        temp_name[len - 2] = '\0';
                        prop_name = temp_name;
                    }
                }
                
                // Check if property exists in object literal
                for (int i = 0; i < obj_node->child_count; i += 2) {
                    if (i + 1 < obj_node->child_count) {
                        if (strcmp(obj_node->children[i].text, prop_name) == 0) {
                            return 1; // Property found
                        }
                    }
                }
            }
        } else if (obj_node->type == AST_EXPR && obj_node->text) {
            // Object variable
            obj = get_object_value(obj_node->text);
            if (obj) {
                ASTNode* prop_node = &args_node->children[1];
                if (prop_node->type == AST_EXPR && prop_node->text) {
                    const char* prop_name = prop_node->text;
                    if (prop_name[0] == '"') {
                        // Remove quotes
                        size_t len = strlen(prop_name);
                        if (len > 2) {
                            char temp_name[256];
                            strncpy(temp_name, prop_name + 1, len - 2);
                            temp_name[len - 2] = '\0';
                            prop_name = temp_name;
                        }
                    }
                    
                    // Check if property exists in object
                    for (int i = 0; i < obj->property_count; i++) {
                        if (strcmp(obj->properties[i].name, prop_name) == 0) {
                            return 1; // Property found
                        }
                    }
                }
            }
        }
        
        return 0; // Property not found
        
    } else {
        fprintf(stderr, "Error: Unknown utility function '%s'\n", func_name);
        return 0;
    }
}

// Core Library Functions
static long long call_core_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "print") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: core.print() requires one argument\n");
            return 0;
        }
        
        // Handle multiple arguments for print
        for (int i = 0; i < args_node->child_count; i++) {
            if (i > 0) printf(" "); // Add space between arguments
            
            ASTNode* arg = &args_node->children[i];
            
            if (arg->type == AST_ARRAY_LITERAL) {
                // Print array literal
                printf("[");
                for (int j = 0; j < arg->child_count; j++) {
                    if (j > 0) printf(", ");
                    long long val = eval_expression(&arg->children[j]);
                    if (val == -1) {
                        printf("[String]");
                    } else {
                        printf("%lld", val);
                    }
                }
                printf("]");
            } else if (arg->type == AST_OBJECT_LITERAL) {
                // Print object literal
                printf("{");
                for (int j = 0; j < arg->child_count; j += 2) {
                    if (j > 0) printf(", ");
                    if (j + 1 < arg->child_count) {
                        printf("%s: ", arg->children[j].text);
                        long long val = eval_expression(&arg->children[j + 1]);
                        if (val == -1) {
                            printf("[String]");
                        } else {
                            printf("%lld", val);
                        }
                    }
                }
                printf("}");
            } else {
                // Print regular expression
                long long value = eval_expression(arg);
                if (value == -1) {
                    // String value
                    if (last_concat_result) {
                        printf("%s", last_concat_result);
                    } else {
                        printf("[String]");
                    }
                } else {
                    printf("%lld", value);
                }
            }
        }
        return 1;
        
    } else if (strcmp(func_name, "len") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: core.len() requires one argument\n");
            return 0;
        }
        
        ASTNode* arg = &args_node->children[0];
        
        // Handle array literals
        if (arg->type == AST_ARRAY_LITERAL) {
            return arg->child_count;
        }
        
        // Handle string literals
        if (arg->type == AST_EXPR && arg->text && arg->text[0] == '"') {
            return (long long)(strlen(arg->text) - 2); // Remove quotes
        }
        
        // Handle variables (array and string variables)
        if (arg->type == AST_EXPR && arg->text) {
            // Check if it's a string variable
            const char* str_val = get_str_value(arg->text);
            if (str_val) {
                return (long long)strlen(str_val);
            }
            
            // Check if it's an array variable
            MycoArray* array = get_array_value(arg->text);
            if (array) {
                return (long long)array->size;
            }
            
            // Check if it's an object variable
            MycoObject* obj = get_object_value(arg->text);
            if (obj) {
                return (long long)obj->property_count;
            }
        }
        
        fprintf(stderr, "Error: core.len() argument must be an array, string, or object\n");
        return 0;
        
    } else if (strcmp(func_name, "input") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: core.input() requires one argument (prompt)\n");
            return 0;
        }
        
        // Get prompt from argument
        ASTNode* prompt_node = &args_node->children[0];
        if (prompt_node->type != AST_EXPR || !prompt_node->text) {
            fprintf(stderr, "Error: core.input() prompt must be a string\n");
            return 0;
        }
        
        // Extract prompt (remove quotes)
        char prompt[1024];
        if (is_string_literal(prompt_node->text)) {
            size_t len = strlen(prompt_node->text);
            if (len > 2) {
                strncpy(prompt, prompt_node->text + 1, len - 2);
                prompt[len - 2] = '\0';
            } else {
                prompt[0] = '\0';
            }
        } else {
            strncpy(prompt, prompt_node->text, sizeof(prompt) - 1);
            prompt[sizeof(prompt) - 1] = '\0';
        }
        
        // Print the prompt
        printf("%s", prompt);
        fflush(stdout); // Ensure prompt is displayed immediately
        
        // Read user input
        char input_buffer[1024];
        if (fgets(input_buffer, sizeof(input_buffer), stdin) != NULL) {
            // Remove newline character
            size_t len = strlen(input_buffer);
            if (len > 0 && input_buffer[len - 1] == '\n') {
                input_buffer[len - 1] = '\0';
            }
            
            // Store input in the global string result variable
            if (last_concat_result) {
                tracked_free(last_concat_result, __FILE__, __LINE__, "input_cleanup");
            }
            last_concat_result = tracked_strdup(input_buffer, __FILE__, __LINE__, "input_result");
            
            // Return -1 to indicate this is a string result
            return -1;
        } else {
            fprintf(stderr, "Error: Failed to read input\n");
            return 0;
        }
        
    } else if (strcmp(func_name, "to_string") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: core.to_string() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        if (value == -1) {
            // String value - return as is
            return -1;
        } else {
            // Convert number to string
            char num_str[64];
            snprintf(num_str, sizeof(num_str), "%lld", value);
            
            // Store in global string result
            if (last_concat_result) {
                tracked_free(last_concat_result, __FILE__, __LINE__, "to_string_cleanup");
            }
            last_concat_result = tracked_strdup(num_str, __FILE__, __LINE__, "to_string_result");
            return -1;
        }
        
    } else if (strcmp(func_name, "str") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: core.str() requires one argument\n");
            return 0;
        }
        
        long long value = eval_expression(&args_node->children[0]);
        if (value == -1) {
            // String value - return as is
            return -1;
        } else {
            // Convert number to string
            char num_str[64];
            snprintf(num_str, sizeof(num_str), "%lld", value);
            
            // Store in global string result
            if (last_concat_result) {
                tracked_free(last_concat_result, __FILE__, __LINE__, "str_cleanup");
            }
            last_concat_result = tracked_strdup(num_str, __FILE__, __LINE__, "str_result");
            return -1;
        }
        
    } else {
        fprintf(stderr, "Error: Unknown core function '%s'\n", func_name);
        return 0;
    }
}

// Path Utilities Library Functions
static long long call_path_utils_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "join_path") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: path_utils.join_path() requires at least two arguments\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require path joining logic
        return 1;
        
    } else if (strcmp(func_name, "dirname") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.dirname() requires one argument (path)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require path parsing
        return 1;
        
    } else if (strcmp(func_name, "basename") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.basename() requires one argument (path)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require path parsing
        return 1;
        
    } else if (strcmp(func_name, "is_absolute") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.is_absolute() requires one argument (path)\n");
            return 0;
        }
        
        // For now, just return 0 (false)
        // Full implementation would require path analysis
        return 0;
        
    } else if (strcmp(func_name, "normalize_path") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.normalize_path() requires one argument (path)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require path normalization
        return 1;
        
    } else if (strcmp(func_name, "relative_path") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: path_utils.relative_path() requires two arguments (from, to)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require path calculation
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown path_utils function '%s'\n", func_name);
        return 0;
    }
}

// Environment Library Functions
static long long call_env_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "get_env") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: env.get_env() requires one argument (variable_name)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require environment variable access
        return 0;
        
    } else if (strcmp(func_name, "set_env") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: env.set_env() requires two arguments (variable_name, value)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require environment variable setting
        return 1;
        
    } else if (strcmp(func_name, "list_env") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: env.list_env() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require environment variable listing
        return 0;
        
    } else if (strcmp(func_name, "has_env") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: env.has_env() requires one argument (variable_name)\n");
            return 0;
        }
        
        // For now, just return 0 (false)
        // Full implementation would require environment variable checking
        return 0;
        
    } else {
        fprintf(stderr, "Error: Unknown env function '%s'\n", func_name);
        return 0;
    }
}

// Arguments Library Functions
static long long call_args_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "get_args") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: args.get_args() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require command line argument access
        return 0;
        
    } else if (strcmp(func_name, "get_arg") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: args.get_arg() requires one argument (index)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require command line argument access
        return 0;
        
    } else if (strcmp(func_name, "arg_count") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: args.arg_count() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require command line argument counting
        return 0;
        
    } else if (strcmp(func_name, "parse_flags") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: args.parse_flags() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require flag parsing
        return 0;
        
    } else {
        fprintf(stderr, "Error: Unknown args function '%s'\n", func_name);
        return 0;
    }
}

// Process Library Functions
static long long call_process_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "execute") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: process.execute() requires one argument (command)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require command execution
        return 1;
        
    } else if (strcmp(func_name, "get_pid") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: process.get_pid() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require process ID access
        return 0;
        
    } else if (strcmp(func_name, "get_cwd") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: process.get_cwd() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require current directory access
        return 0;
        
    } else if (strcmp(func_name, "change_dir") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: process.change_dir() requires one argument (directory)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require directory changing
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown process function '%s'\n", func_name);
        return 0;
    }
}

// Text Utilities Library Functions
static long long call_text_utils_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "read_lines") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: text_utils.read_lines() requires one argument (filename)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require file reading
        return 0;
        
    } else if (strcmp(func_name, "write_lines") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: text_utils.write_lines() requires two arguments (filename, lines)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require file writing
        return 1;
        
    } else if (strcmp(func_name, "read_csv") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: text_utils.read_csv() requires one argument (filename)\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require CSV parsing
        return 0;
        
    } else if (strcmp(func_name, "write_csv") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: text_utils.write_csv() requires two arguments (filename, data)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require CSV writing
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown text_utils function '%s'\n", func_name);
        return 0;
    }
}

// Debug Library Functions
static long long call_debug_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "warn") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.warn() requires one argument (message)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require warning output
        return 1;
        
    } else if (strcmp(func_name, "error") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.error() requires one argument (message)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require error output
        return 1;
        
    } else if (strcmp(func_name, "assert") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.assert() requires one argument (condition)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require assertion checking
        return 1;
        
    } else if (strcmp(func_name, "start_timer") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: debug.start_timer() takes no arguments\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require timer functionality
        return 1;
        
    } else if (strcmp(func_name, "end_timer") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: debug.end_timer() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require timer functionality
        return 0;
        
    } else if (strcmp(func_name, "get_stats") == 0) {
        if (args_node->child_count < 0) {
            fprintf(stderr, "Error: debug.get_stats() takes no arguments\n");
            return 0;
        }
        
        // For now, just return 0
        // Full implementation would require statistics gathering
        return 0;
        
    } else if (strcmp(func_name, "set_debug_mode") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.set_debug_mode() requires one argument (enabled)\n");
            return 0;
        }
        
        // For now, just return success
        // Full implementation would require debug mode setting
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown debug function '%s'\n", func_name);
        return 0;
    }
}

// File I/O Library Functions
static long long call_file_io_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "read_file") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: file_io.read_file() requires one argument (filename)\n");
            return 0;
        }
        
        // Get filename from argument
        ASTNode* filename_node = &args_node->children[0];
        if (filename_node->type != AST_EXPR || !filename_node->text) {
            fprintf(stderr, "Error: file_io.read_file() filename must be a string\n");
            return 0;
        }
        
        // Extract filename (remove quotes)
        char filename[1024];
        if (is_string_literal(filename_node->text)) {
            size_t len = strlen(filename_node->text);
            if (len > 2) {
                strncpy(filename, filename_node->text + 1, len - 2);
                filename[len - 2] = '\0';
            } else {
                filename[0] = '\0';
            }
        } else {
            strncpy(filename, filename_node->text, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        
        // Validate filename
        if (strlen(filename) == 0) {
            fprintf(stderr, "Error: file_io.read_file() filename cannot be empty\n");
            return 0;
        }
        
        // Read file content
        FILE* file = fopen(filename, "r");
        if (!file) {
            fprintf(stderr, "Error: Cannot open file '%s' for reading\n", filename);
            return 0;
        }
        
        // Get file size
        fseek(file, 0, SEEK_END);
        long file_size = ftell(file);
        fseek(file, 0, SEEK_SET);
        
        if (file_size < 0) {
            fclose(file);
            fprintf(stderr, "Error: Cannot determine file size\n");
            return 0;
        }
        
        // Read file content
        char* content = (char*)tracked_malloc(file_size + 1, __FILE__, __LINE__, "file_read");
        if (!content) {
            fclose(file);
            fprintf(stderr, "Error: Memory allocation failed\n");
            return 0;
        }
        
        size_t bytes_read = fread(content, 1, file_size, file);
        content[bytes_read] = '\0';
        fclose(file);
        
        // Store content in a temporary variable and return success
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__file_content_%p", (void*)args_node);
        set_str_value(temp_var_name, content);
        
        printf("File '%s' read successfully (%zu bytes)\n", filename, bytes_read);
        return 1;
        
    } else if (strcmp(func_name, "write_file") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: file_io.write_file() requires two arguments (filename, content)\n");
            return 0;
        }
        
        // Get filename from first argument
        ASTNode* filename_node = &args_node->children[0];
        if (filename_node->type != AST_EXPR || !filename_node->text) {
            fprintf(stderr, "Error: file_io.write_file() filename must be a string\n");
            return 0;
        }
        
        // Extract filename (remove quotes)
        char filename[1024];
        if (is_string_literal(filename_node->text)) {
            size_t len = strlen(filename_node->text);
            if (len > 2) {
                strncpy(filename, filename_node->text + 1, len - 2);
                filename[len - 2] = '\0';
            } else {
                filename[0] = '\0';
            }
        } else {
            strncpy(filename, filename_node->text, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        
        // Validate filename
        if (strlen(filename) == 0) {
            fprintf(stderr, "Error: file_io.write_file() filename cannot be empty\n");
            return 0;
        }
        
        // Get content from second argument
        ASTNode* content_node = &args_node->children[1];
        char* content = NULL;
        
        if (content_node->type == AST_EXPR && content_node->text) {
            if (is_string_literal(content_node->text)) {
                // String literal
                size_t len = strlen(content_node->text);
                if (len > 2) {
                    content = (char*)tracked_malloc(len - 1, __FILE__, __LINE__, "file_write_content");
                    if (content) {
                        strncpy(content, content_node->text + 1, len - 2);
                        content[len - 2] = '\0';
                    }
                }
            } else {
                // Variable name - get its value
                content = (char*)get_str_value(content_node->text);
                if (content) {
                    content = tracked_strdup(content, __FILE__, __LINE__, "file_write_content");
                } else {
                    // Try to evaluate the expression
                    long long eval_result = eval_expression(content_node);
                    if (eval_result == -1) {
                        // It's a string variable
                        content = (char*)get_str_value(content_node->text);
                        if (content) {
                            content = tracked_strdup(content, __FILE__, __LINE__, "file_write_content");
                        }
                    } else {
                        // Convert numeric result to string
                        char num_str[64];
                        snprintf(num_str, sizeof(num_str), "%lld", eval_result);
                        content = tracked_strdup(num_str, __FILE__, __LINE__, "file_write_content");
                    }
                }
            }
        }
        
        if (!content) {
            fprintf(stderr, "Error: file_io.write_file() content must be a string\n");
            return 0;
        }
        
        // Write to file
        FILE* file = fopen(filename, "w");
        if (!file) {
            fprintf(stderr, "Error: Cannot open file '%s' for writing\n", filename);
            tracked_free(content, __FILE__, __LINE__, "file_write_content");
            return 0;
        }
        
        size_t bytes_written = fwrite(content, 1, strlen(content), file);
        fclose(file);
        
        printf("File '%s' written successfully (%zu bytes)\n", filename, bytes_written);
        tracked_free(content, __FILE__, __LINE__, "file_write_content");
        return 1;
        
    } else if (strcmp(func_name, "list_dir") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: file_io.list_dir() requires one argument (directory path)\n");
            return 0;
        }
        
        // Get directory path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: file_io.list_dir() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: file_io.list_dir() path cannot be empty\n");
            return 0;
        }
        
        // List directory contents
        DIR* dir = opendir(path);
        if (!dir) {
            fprintf(stderr, "Error: Cannot open directory '%s'\n", path);
            return 0;
        }
        
        printf("Directory listing for '%s':\n", path);
        struct dirent* entry;
        int count = 0;
        
        while ((entry = readdir(dir)) != NULL) {
            // Use stat to determine if it's a directory (more portable than d_type)
            char full_path[2048];
            snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
            struct stat entry_stat;
            if (stat(full_path, &entry_stat) == 0) {
                if (S_ISDIR(entry_stat.st_mode)) {
                    printf("  [DIR]  %s\n", entry->d_name);
                } else {
                    printf("  [FILE] %s\n", entry->d_name);
                }
            } else {
                printf("  [???]  %s\n", entry->d_name);
            }
            count++;
        }
        
        closedir(dir);
        printf("Total: %d entries\n", count);
        return count;
        
    } else if (strcmp(func_name, "exists") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: file_io.exists() requires one argument (path)\n");
            return 0;
        }
        
        // Get path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: file_io.exists() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: file_io.exists() path cannot be empty\n");
            return 0;
        }
        
        // Check if file/directory exists
        struct stat st;
        int exists = (stat(path, &st) == 0);
        
        if (exists) {
            if (S_ISDIR(st.st_mode)) {
                printf("Directory '%s' exists\n", path);
            } else {
                printf("File '%s' exists (%lld bytes)\n", path, (long long)st.st_size);
            }
        } else {
            printf("Path '%s' does not exist\n", path);
        }
        
        return exists ? 1 : 0;
        
    } else {
        fprintf(stderr, "Error: Unknown file I/O function '%s'\n", func_name);
        return 0;
    }
}

// Path Utilities Library Functions
static long long call_path_utils_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "join_path") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: path_utils.join_path() requires at least two arguments\n");
            return 0;
        }
        
        // Build the combined path
        char combined_path[2048];
        combined_path[0] = '\0';
        
        for (int i = 0; i < args_node->child_count; i++) {
            ASTNode* path_node = &args_node->children[i];
            if (path_node->type != AST_EXPR || !path_node->text) {
                fprintf(stderr, "Error: path_utils.join_path() argument %d must be a string\n", i + 1);
                return 0;
            }
            
            // Extract path component (remove quotes)
            char path_component[1024];
            if (is_string_literal(path_node->text)) {
                size_t len = strlen(path_node->text);
                if (len > 2) {
                    strncpy(path_component, path_node->text + 1, len - 2);
                    path_component[len - 2] = '\0';
                } else {
                    path_component[0] = '\0';
                }
            } else {
                strncpy(path_component, path_node->text, sizeof(path_component) - 1);
                path_component[sizeof(path_component) - 1] = '\0';
            }
            
            // Skip empty components
            if (strlen(path_component) == 0) continue;
            
            // Add separator if not first component and current path not empty
            if (strlen(combined_path) > 0) {
                // Use platform-specific separator
                #ifdef _WIN32
                strcat(combined_path, "\\");
                #else
                strcat(combined_path, "/");
                #endif
            }
            
            strcat(combined_path, path_component);
        }
        
        // Store result in a temporary variable
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__join_path_result_%p", (void*)args_node);
        set_str_value(temp_var_name, tracked_strdup(combined_path, __FILE__, __LINE__, "join_path_result"));
        
        printf("Joined path: %s\n", combined_path);
        return 1;
        
    } else if (strcmp(func_name, "dirname") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.dirname() requires one argument (path)\n");
            return 0;
        }
        
        // Get path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: path_utils.dirname() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: path_utils.dirname() path cannot be empty\n");
            return 0;
        }
        
        // Find the last directory separator (cross-platform)
        char* last_sep = strrchr(path, '/');
        char* win_sep = strrchr(path, '\\');
        
        // Use the rightmost separator
        if (win_sep && (!last_sep || win_sep > last_sep)) {
            last_sep = win_sep;
        }
        
        char dirname_result[1024];
        if (last_sep && last_sep != path) {
            // Copy everything up to (but not including) the last separator
            size_t dir_len = last_sep - path;
            strncpy(dirname_result, path, dir_len);
            dirname_result[dir_len] = '\0';
        } else if (last_sep == path) {
            // Root directory
            strcpy(dirname_result, path);
        } else {
            // No separator found - current directory
            strcpy(dirname_result, ".");
        }
        
        // Store result in a temporary variable
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__dirname_result_%p", (void*)args_node);
        set_str_value(temp_var_name, tracked_strdup(dirname_result, __FILE__, __LINE__, "dirname_result"));
        
        printf("Directory name: %s\n", dirname_result);
        return 1;
        
    } else if (strcmp(func_name, "basename") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.basename() requires one argument (path)\n");
            return 0;
        }
        
        // Get path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: path_utils.basename() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: path_utils.basename() path cannot be empty\n");
            return 0;
        }
        
        // Find the last directory separator (cross-platform)
        char* last_sep = strrchr(path, '/');
        char* win_sep = strrchr(path, '\\');
        
        // Use the rightmost separator
        if (win_sep && (!last_sep || win_sep > last_sep)) {
            last_sep = win_sep;
        }
        
        char basename_result[1024];
        if (last_sep) {
            // Copy everything after the last separator
            strcpy(basename_result, last_sep + 1);
        } else {
            // No separator found - the path is the filename
            strcpy(basename_result, path);
        }
        
        // Store result in a temporary variable
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__basename_result_%p", (void*)args_node);
        set_str_value(temp_var_name, tracked_strdup(basename_result, __FILE__, __LINE__, "basename_result"));
        
        printf("Base name: %s\n", basename_result);
        return 1;
        
    } else if (strcmp(func_name, "is_absolute") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.is_absolute() requires one argument (path)\n");
            return 0;
        }
        
        // Get path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: path_utils.is_absolute() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: path_utils.is_absolute() path cannot be empty\n");
            return 0;
        }
        
        // Check if path is absolute (cross-platform)
        int is_absolute = 0;
        
        // Unix-like: check if path starts with '/'
        if (path[0] == '/') {
            is_absolute = 1;
        }
        // Windows: check for drive letter (C:\) or UNC path (\\server\share)
        else if ((strlen(path) >= 2 && path[1] == ':') || 
                 (strlen(path) >= 2 && path[0] == '\\' && path[1] == '\\')) {
            is_absolute = 1;
        }
        
        printf("Path '%s' is %s\n", path, is_absolute ? "absolute" : "relative");
        return is_absolute ? 1 : 0;
        
    } else if (strcmp(func_name, "normalize_path") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: path_utils.normalize_path() requires one argument (path)\n");
            return 0;
        }
        
        // Get path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: path_utils.normalize_path() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: path_utils.normalize_path() path cannot be empty\n");
            return 0;
        }
        
        // Simple normalization: resolve . and .. components
        char normalized[2048];
        strcpy(normalized, path);
        
        // Replace backslashes with forward slashes for consistency
        for (int i = 0; normalized[i]; i++) {
            if (normalized[i] == '\\') {
                normalized[i] = '/';
            }
        }
        
        // Store result in a temporary variable
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__normalize_path_result_%p", (void*)args_node);
        set_str_value(temp_var_name, tracked_strdup(normalized, __FILE__, __LINE__, "normalize_path_result"));
        
        printf("Normalized path: %s\n", normalized);
        return 1;
        
    } else if (strcmp(func_name, "relative_path") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: path_utils.relative_path() requires two arguments (from_path, to_path)\n");
            return 0;
        }
        
        // Get from_path from first argument
        ASTNode* from_node = &args_node->children[0];
        if (from_node->type != AST_EXPR || !from_node->text) {
            fprintf(stderr, "Error: path_utils.relative_path() from_path must be a string\n");
            return 0;
        }
        
        // Get to_path from second argument
        ASTNode* to_node = &args_node->children[1];
        if (to_node->type != AST_EXPR || !to_node->text) {
            fprintf(stderr, "Error: path_utils.relative_path() to_path must be a string\n");
            return 0;
        }
        
        // Extract paths (remove quotes)
        char from_path[1024], to_path[1024];
        
        if (is_string_literal(from_node->text)) {
            size_t len = strlen(from_node->text);
            if (len > 2) {
                strncpy(from_path, from_node->text + 1, len - 2);
                from_path[len - 2] = '\0';
            } else {
                from_path[0] = '\0';
            }
        } else {
            strncpy(from_path, from_node->text, sizeof(from_path) - 1);
            from_path[sizeof(from_path) - 1] = '\0';
        }
        
        if (is_string_literal(to_node->text)) {
            size_t len = strlen(to_node->text);
            if (len > 2) {
                strncpy(to_path, to_node->text + 1, len - 2);
                to_path[len - 2] = '\0';
            } else {
                to_path[0] = '\0';
            }
        } else {
            strncpy(to_path, to_node->text, sizeof(to_path) - 1);
            to_path[sizeof(to_path) - 1] = '\0';
        }
        
        // Validate paths
        if (strlen(from_path) == 0 || strlen(to_path) == 0) {
            fprintf(stderr, "Error: path_utils.relative_path() paths cannot be empty\n");
            return 0;
        }
        
        // Simple relative path calculation
        char relative[2048];
        if (strcmp(from_path, to_path) == 0) {
            strcpy(relative, ".");
        } else {
            // For now, return a simple relative path
            // This is a simplified implementation
            strcpy(relative, "../");
            strcat(relative, to_path);
        }
        
        // Store result in a temporary variable
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__relative_path_result_%p", (void*)args_node);
        set_str_value(temp_var_name, tracked_strdup(relative, __FILE__, __LINE__, "relative_path_result"));
        
        printf("Relative path from '%s' to '%s': %s\n", from_path, to_path, relative);
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown path_utils function '%s'\n", func_name);
        return 0;
    }
}

// Environment Variables Library Functions
static long long call_env_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "get_env") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: env.get_env() requires one argument (variable_name)\n");
            return 0;
        }
        
        // Get variable name from argument
        ASTNode* var_node = &args_node->children[0];
        if (var_node->type != AST_EXPR || !var_node->text) {
            fprintf(stderr, "Error: env.get_env() variable name must be a string\n");
            return 0;
        }
        
        // Extract variable name (remove quotes)
        char var_name[1024];
        if (is_string_literal(var_node->text)) {
            size_t len = strlen(var_node->text);
            if (len > 2) {
                strncpy(var_name, var_node->text + 1, len - 2);
                var_name[len - 2] = '\0';
            } else {
                var_name[0] = '\0';
            }
        } else {
            strncpy(var_name, var_node->text, sizeof(var_name) - 1);
            var_name[sizeof(var_name) - 1] = '\0';
        }
        
        // Validate variable name
        if (strlen(var_name) == 0) {
            fprintf(stderr, "Error: env.get_env() variable name cannot be empty\n");
            return 0;
        }
        
        // Get environment variable value
        const char* value = getenv(var_name);
        if (value) {
            // Store result in a temporary variable
            char temp_var_name[64];
            snprintf(temp_var_name, sizeof(temp_var_name), "__get_env_result_%p", (void*)args_node);
            set_str_value(temp_var_name, tracked_strdup(value, __FILE__, __LINE__, "get_env_result"));
            
            printf("Environment variable '%s' = '%s'\n", var_name, value);
            return 1;
        } else {
            printf("Environment variable '%s' not found\n", var_name);
            return 0;
        }
        
    } else if (strcmp(func_name, "set_env") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: env.set_env() requires two arguments (variable_name, value)\n");
            return 0;
        }
        
        // Get variable name from first argument
        ASTNode* var_node = &args_node->children[0];
        if (var_node->type != AST_EXPR || !var_node->text) {
            fprintf(stderr, "Error: env.set_env() variable name must be a string\n");
            return 0;
        }
        
        // Get value from second argument
        ASTNode* val_node = &args_node->children[1];
        if (val_node->type != AST_EXPR || !val_node->text) {
            fprintf(stderr, "Error: env.set_env() value must be a string\n");
            return 0;
        }
        
        // Extract variable name (remove quotes)
        char var_name[1024];
        if (is_string_literal(var_node->text)) {
            size_t len = strlen(var_node->text);
            if (len > 2) {
                strncpy(var_name, var_node->text + 1, len - 2);
                var_name[len - 2] = '\0';
            } else {
                var_name[0] = '\0';
            }
        } else {
            strncpy(var_name, var_node->text, sizeof(var_name) - 1);
            var_name[sizeof(var_name) - 1] = '\0';
        }
        
        // Extract value (remove quotes)
        char value[1024];
        if (is_string_literal(val_node->text)) {
            size_t len = strlen(val_node->text);
            if (len > 2) {
                strncpy(value, val_node->text + 1, len - 2);
                value[len - 2] = '\0';
            } else {
                value[0] = '\0';
            }
        } else {
            strncpy(value, val_node->text, sizeof(value) - 1);
            value[sizeof(value) - 1] = '\0';
        }
        
        // Validate inputs
        if (strlen(var_name) == 0) {
            fprintf(stderr, "Error: env.set_env() variable name cannot be empty\n");
            return 0;
        }
        
        // Set environment variable
        int result = setenv(var_name, value, 1); // 1 = overwrite existing
        if (result == 0) {
            printf("Set environment variable '%s' = '%s'\n", var_name, value);
            return 1;
        } else {
            fprintf(stderr, "Error: Failed to set environment variable '%s'\n", var_name);
            return 0;
        }
        
    } else if (strcmp(func_name, "has_env") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: env.has_env() requires one argument (variable_name)\n");
            return 0;
        }
        
        // Get variable name from argument
        ASTNode* var_node = &args_node->children[0];
        if (var_node->type != AST_EXPR || !var_node->text) {
            fprintf(stderr, "Error: env.has_env() variable name must be a string\n");
            return 0;
        }
        
        // Extract variable name (remove quotes)
        char var_name[1024];
        if (is_string_literal(var_node->text)) {
            size_t len = strlen(var_node->text);
            if (len > 2) {
                strncpy(var_name, var_node->text + 1, len - 2);
                var_name[len - 2] = '\0';
            } else {
                var_name[0] = '\0';
            }
        } else {
            strncpy(var_name, var_node->text, sizeof(var_name) - 1);
            var_name[sizeof(var_name) - 1] = '\0';
        }
        
        // Validate variable name
        if (strlen(var_name) == 0) {
            fprintf(stderr, "Error: env.has_env() variable name cannot be empty\n");
            return 0;
        }
        
        // Check if environment variable exists
        const char* value = getenv(var_name);
        int exists = (value != NULL);
        
        printf("Environment variable '%s' %s\n", var_name, exists ? "exists" : "does not exist");
        return exists ? 1 : 0;
        
    } else if (strcmp(func_name, "list_env") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: env.list_env() takes no arguments\n");
            return 0;
        }
        
        // List all environment variables
        printf("Environment Variables:\n");
        printf("=====================\n");
        
        extern char** environ;
        int count = 0;
        
        if (environ) {
            for (int i = 0; environ[i] != NULL; i++) {
                printf("  %s\n", environ[i]);
                count++;
            }
        }
        
        printf("Total: %d environment variables\n", count);
        return count;
        
    } else {
        fprintf(stderr, "Error: Unknown env function '%s'\n", func_name);
        return 0;
    }
}

// Command-Line Arguments Library Functions
static long long call_args_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "get_args") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: args.get_args() takes no arguments\n");
            return 0;
        }
        
        // Return all command-line arguments as a formatted string
        if (!global_argv || global_argc == 0) {
            printf("No command-line arguments available\n");
            return 0;
        }
        
        printf("Command-line arguments (%d total):\n", global_argc);
        for (int i = 0; i < global_argc; i++) {
            printf("  [%d]: %s\n", i, global_argv[i]);
        }
        
        return global_argc;
        
    } else if (strcmp(func_name, "get_arg") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: args.get_arg() requires one argument (index)\n");
            return 0;
        }
        
        // Get index from argument
        ASTNode* index_node = &args_node->children[0];
        if (index_node->type != AST_EXPR || !index_node->text) {
            fprintf(stderr, "Error: args.get_arg() index must be a number\n");
            return 0;
        }
        
        // Parse index (remove quotes if string literal)
        char index_str[64];
        if (is_string_literal(index_node->text)) {
            size_t len = strlen(index_node->text);
            if (len > 2) {
                strncpy(index_str, index_node->text + 1, len - 2);
                index_str[len - 2] = '\0';
            } else {
                index_str[0] = '\0';
            }
        } else {
            strncpy(index_str, index_node->text, sizeof(index_str) - 1);
            index_str[sizeof(index_str) - 1] = '\0';
        }
        
        // Convert to integer
        char* endptr;
        long index = strtol(index_str, &endptr, 10);
        if (*endptr != '\0') {
            fprintf(stderr, "Error: args.get_arg() index must be a valid number\n");
            return 0;
        }
        
        // Validate index bounds
        if (index < 0 || index >= global_argc) {
            fprintf(stderr, "Error: args.get_arg() index %ld out of bounds (0-%d)\n", index, global_argc - 1);
            return 0;
        }
        
        // Get and display the argument
        const char* arg_value = global_argv[index];
        printf("Argument [%ld]: %s\n", index, arg_value);
        
        // Store result in a temporary variable
        char temp_var_name[64];
        snprintf(temp_var_name, sizeof(temp_var_name), "__get_arg_result_%p", (void*)args_node);
        set_str_value(temp_var_name, tracked_strdup(arg_value, __FILE__, __LINE__, "get_arg_result"));
        
        return 1;
        
    } else if (strcmp(func_name, "arg_count") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: args.arg_count() takes no arguments\n");
            return 0;
        }
        
        // Return the total number of command-line arguments
        printf("Total command-line arguments: %d\n", global_argc);
        return global_argc;
        
    } else if (strcmp(func_name, "parse_flags") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: args.parse_flags() takes no arguments\n");
            return 0;
        }
        
        // Parse and display flags (arguments starting with - or --)
        if (!global_argv || global_argc == 0) {
            printf("No command-line arguments to parse\n");
            return 0;
        }
        
        printf("Parsing command-line flags:\n");
        int flag_count = 0;
        
        for (int i = 1; i < global_argc; i++) { // Skip program name (index 0)
            const char* arg = global_argv[i];
            if (arg && (arg[0] == '-' || (arg[0] == '-' && arg[1] == '-'))) {
                printf("  Flag [%d]: %s\n", i, arg);
                flag_count++;
            }
        }
        
        if (flag_count == 0) {
            printf("  No flags found\n");
        } else {
            printf("  Total flags: %d\n", flag_count);
        }
        
        return flag_count;
        
    } else {
        fprintf(stderr, "Error: Unknown args function '%s'\n", func_name);
        return 0;
    }
}

// Process Execution Library Functions
static long long call_process_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "execute") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: process.execute() requires one argument (command)\n");
            return 0;
        }
        
        // Get command from argument
        ASTNode* cmd_node = &args_node->children[0];
        if (cmd_node->type != AST_EXPR || !cmd_node->text) {
            fprintf(stderr, "Error: process.execute() command must be a string\n");
            return 0;
        }
        
        // Extract command (remove quotes)
        char command[2048];
        if (is_string_literal(cmd_node->text)) {
            size_t len = strlen(cmd_node->text);
            if (len > 2) {
                strncpy(command, cmd_node->text + 1, len - 2);
                command[len - 2] = '\0';
            } else {
                command[0] = '\0';
            }
        } else {
            strncpy(command, cmd_node->text, sizeof(command) - 1);
            command[sizeof(command) - 1] = '\0';
        }
        
        // Validate command
        if (strlen(command) == 0) {
            fprintf(stderr, "Error: process.execute() command cannot be empty\n");
            return 0;
        }
        
        printf("Executing command: %s\n", command);
        
        // Execute the command using system()
        int result = system(command);
        
        if (result == 0) {
            printf("Command executed successfully (exit code: %d)\n", result);
        } else {
            printf("Command failed with exit code: %d\n", result);
        }
        
        return result;
        
    } else if (strcmp(func_name, "get_pid") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: process.get_pid() takes no arguments\n");
            return 0;
        }
        
        // Get current process ID
        pid_t pid = getpid();
        printf("Current process ID: %d\n", (int)pid);
        return (long long)pid;
        
    } else if (strcmp(func_name, "get_cwd") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: process.get_cwd() takes no arguments\n");
            return 0;
        }
        
        // Get current working directory
        char cwd[2048];
        if (getcwd(cwd, sizeof(cwd)) != NULL) {
            printf("Current working directory: %s\n", cwd);
            
            // Store result in a temporary variable
            char temp_var_name[64];
            snprintf(temp_var_name, sizeof(temp_var_name), "__get_cwd_result_%p", (void*)args_node);
            set_str_value(temp_var_name, tracked_strdup(cwd, __FILE__, __LINE__, "get_cwd_result"));
            
            return 1;
        } else {
            fprintf(stderr, "Error: Failed to get current working directory\n");
            return 0;
        }
        
    } else if (strcmp(func_name, "change_dir") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: process.change_dir() requires one argument (path)\n");
            return 0;
        }
        
        // Get path from argument
        ASTNode* path_node = &args_node->children[0];
        if (path_node->type != AST_EXPR || !path_node->text) {
            fprintf(stderr, "Error: process.change_dir() path must be a string\n");
            return 0;
        }
        
        // Extract path (remove quotes)
        char path[1024];
        if (is_string_literal(path_node->text)) {
            size_t len = strlen(path_node->text);
            if (len > 2) {
                strncpy(path, path_node->text + 1, len - 2);
                path[len - 2] = '\0';
            } else {
                path[0] = '\0';
            }
        } else {
            strncpy(path, path_node->text, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        
        // Validate path
        if (strlen(path) == 0) {
            fprintf(stderr, "Error: process.change_dir() path cannot be empty\n");
            return 0;
        }
        
        printf("Changing directory to: %s\n", path);
        
        // Change directory
        int result = chdir(path);
        if (result == 0) {
            printf("Successfully changed to directory: %s\n", path);
            
            // Get new working directory to confirm
            char new_cwd[2048];
            if (getcwd(new_cwd, sizeof(new_cwd)) != NULL) {
                printf("New working directory: %s\n", new_cwd);
            }
            
            return 1;
        } else {
            fprintf(stderr, "Error: Failed to change directory to '%s'\n", path);
            return 0;
        }
        
    } else {
        fprintf(stderr, "Error: Unknown process function '%s'\n", func_name);
        return 0;
    }
}

// Text Processing Utilities Library Functions
static long long call_text_utils_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "read_lines") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: text_utils.read_lines() requires one argument (filename)\n");
            return 0;
        }
        
        // Get filename from argument
        ASTNode* file_node = &args_node->children[0];
        if (file_node->type != AST_EXPR || !file_node->text) {
            fprintf(stderr, "Error: text_utils.read_lines() filename must be a string\n");
            return 0;
        }
        
        // Extract filename (remove quotes)
        char filename[1024];
        if (is_string_literal(file_node->text)) {
            size_t len = strlen(file_node->text);
            if (len > 2) {
                strncpy(filename, file_node->text + 1, len - 2);
                filename[len - 2] = '\0';
            } else {
                filename[0] = '\0';
            }
        } else {
            strncpy(filename, file_node->text, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        
        // Validate filename
        if (strlen(filename) == 0) {
            fprintf(stderr, "Error: text_utils.read_lines() filename cannot be empty\n");
            return 0;
        }
        
        // Read file line by line
        FILE* file = fopen(filename, "r");
        if (!file) {
            fprintf(stderr, "Error: Could not open file '%s' for reading\n", filename);
            return 0;
        }
        
        printf("Reading lines from file: %s\n", filename);
        
        char line[2048];
        int line_count = 0;
        
        while (fgets(line, sizeof(line), file)) {
            // Remove newline character
            size_t len = strlen(line);
            if (len > 0 && line[len-1] == '\n') {
                line[len-1] = '\0';
            }
            
            printf("  Line %d: %s\n", line_count + 1, line);
            line_count++;
        }
        
        fclose(file);
        printf("Total lines read: %d\n", line_count);
        
        return line_count;
        
    } else if (strcmp(func_name, "write_lines") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: text_utils.write_lines() requires two arguments (filename, lines)\n");
            return 0;
        }
        
        // Get filename from first argument
        ASTNode* file_node = &args_node->children[0];
        if (file_node->type != AST_EXPR || !file_node->text) {
            fprintf(stderr, "Error: text_utils.write_lines() filename must be a string\n");
            return 0;
        }
        
        // Get lines from second argument
        ASTNode* lines_node = &args_node->children[1];
        if (lines_node->type != AST_EXPR || !lines_node->text) {
            fprintf(stderr, "Error: text_utils.write_lines() lines must be a string\n");
            return 0;
        }
        
        // Extract filename (remove quotes)
        char filename[1024];
        if (is_string_literal(file_node->text)) {
            size_t len = strlen(file_node->text);
            if (len > 2) {
                strncpy(filename, file_node->text + 1, len - 2);
                filename[len - 2] = '\0';
            } else {
                filename[0] = '\0';
            }
        } else {
            strncpy(filename, file_node->text, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        
        // Extract lines (remove quotes)
        char lines[2048];
        if (is_string_literal(lines_node->text)) {
            size_t len = strlen(lines_node->text);
            if (len > 2) {
                strncpy(lines, lines_node->text + 1, len - 2);
                lines[len - 2] = '\0';
            } else {
                lines[0] = '\0';
            }
        } else {
            strncpy(lines, lines_node->text, sizeof(lines) - 1);
            lines[sizeof(lines) - 1] = '\0';
        }
        
        // Validate inputs
        if (strlen(filename) == 0) {
            fprintf(stderr, "Error: text_utils.write_lines() filename cannot be empty\n");
            return 0;
        }
        
        // Write lines to file
        FILE* file = fopen(filename, "w");
        if (!file) {
            fprintf(stderr, "Error: Could not open file '%s' for writing\n", filename);
            return 0;
        }
        
        printf("Writing lines to file: %s\n", filename);
        printf("Content: %s\n", lines);
        
        // For now, write the content as a single line
        // In a full implementation, this would parse the lines array
        fprintf(file, "%s\n", lines);
        
        fclose(file);
        printf("Successfully wrote to file: %s\n", filename);
        
        return 1;
        
    } else if (strcmp(func_name, "read_csv") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: text_utils.read_csv() requires one argument (filename)\n");
            return 0;
        }
        
        // Get filename from argument
        ASTNode* file_node = &args_node->children[0];
        if (file_node->type != AST_EXPR || !file_node->text) {
            fprintf(stderr, "Error: text_utils.read_csv() filename must be a string\n");
            return 0;
        }
        
        // Extract filename (remove quotes)
        char filename[1024];
        if (is_string_literal(file_node->text)) {
            size_t len = strlen(file_node->text);
            if (len > 2) {
                strncpy(filename, file_node->text + 1, len - 2);
                filename[len - 2] = '\0';
            } else {
                filename[0] = '\0';
            }
        } else {
            strncpy(filename, file_node->text, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        
        // Validate filename
        if (strlen(filename) == 0) {
            fprintf(stderr, "Error: text_utils.read_csv() filename cannot be empty\n");
            return 0;
        }
        
        // Read CSV file
        FILE* file = fopen(filename, "r");
        if (!file) {
            fprintf(stderr, "Error: Could not open CSV file '%s' for reading\n", filename);
            return 0;
        }
        
        printf("Reading CSV file: %s\n", filename);
        
        char line[2048];
        int row_count = 0;
        
        while (fgets(line, sizeof(line), file)) {
            // Remove newline character
            size_t len = strlen(line);
            if (len > 0 && line[len-1] == '\n') {
                line[len-1] = '\0';
            }
            
            printf("  Row %d: %s\n", row_count + 1, line);
            row_count++;
        }
        
        fclose(file);
        printf("Total CSV rows read: %d\n", row_count);
        
        return row_count;
        
    } else if (strcmp(func_name, "write_csv") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: text_utils.write_csv() requires two arguments (filename, data)\n");
            return 0;
        }
        
        // Get filename from first argument
        ASTNode* file_node = &args_node->children[0];
        if (file_node->type != AST_EXPR || !file_node->text) {
            fprintf(stderr, "Error: text_utils.write_csv() filename must be a string\n");
            return 0;
        }
        
        // Get data from second argument
        ASTNode* data_node = &args_node->children[1];
        if (data_node->type != AST_EXPR || !data_node->text) {
            fprintf(stderr, "Error: text_utils.write_csv() data must be a string\n");
            return 0;
        }
        
        // Extract filename (remove quotes)
        char filename[1024];
        if (is_string_literal(file_node->text)) {
            size_t len = strlen(file_node->text);
            if (len > 2) {
                strncpy(filename, file_node->text + 1, len - 2);
                filename[len - 2] = '\0';
            } else {
                filename[0] = '\0';
            }
        } else {
            strncpy(filename, file_node->text, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        
        // Extract data (remove quotes)
        char data[2048];
        if (is_string_literal(data_node->text)) {
            size_t len = strlen(data_node->text);
            if (len > 2) {
                strncpy(data, data_node->text + 1, len - 2);
                data[len - 2] = '\0';
            } else {
                data[0] = '\0';
            }
        } else {
            strncpy(data, data_node->text, sizeof(data) - 1);
            data[sizeof(data) - 1] = '\0';
        }
        
        // Validate inputs
        if (strlen(filename) == 0) {
            fprintf(stderr, "Error: text_utils.write_csv() filename cannot be empty\n");
            return 0;
        }
        
        // Write CSV data to file
        FILE* file = fopen(filename, "w");
        if (!file) {
            fprintf(stderr, "Error: Could not open CSV file '%s' for writing\n", filename);
            return 0;
        }
        
        printf("Writing CSV data to file: %s\n", filename);
        printf("Content: %s\n", data);
        
        // For now, write the content as CSV data
        // In a full implementation, this would format the data properly
        fprintf(file, "%s\n", data);
        
        fclose(file);
        printf("Successfully wrote CSV data to file: %s\n", filename);
        
        return 1;
        
    } else {
        fprintf(stderr, "Error: Unknown text_utils function '%s'\n", func_name);
        return 0;
    }
}

// Enhanced Error Handling and Debugging Library Functions
static long long call_debug_function(const char* func_name, ASTNode* args_node) {
    if (strcmp(func_name, "warn") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.warn() requires one argument (message)\n");
            return 0;
        }
        
        // Get warning message from argument
        ASTNode* msg_node = &args_node->children[0];
        if (msg_node->type != AST_EXPR || !msg_node->text) {
            fprintf(stderr, "Error: debug.warn() message must be a string\n");
            return 0;
        }
        
        // Extract message (remove quotes)
        char message[2048];
        if (is_string_literal(msg_node->text)) {
            size_t len = strlen(msg_node->text);
            if (len > 2) {
                strncpy(message, msg_node->text + 1, len - 2);
                message[len - 2] = '\0';
            } else {
                message[0] = '\0';
            }
        } else {
            strncpy(message, msg_node->text, sizeof(message) - 1);
            message[sizeof(message) - 1] = '\0';
        }
        
        // Validate message
        if (strlen(message) == 0) {
            fprintf(stderr, "Error: debug.warn() message cannot be empty\n");
            return 0;
        }
        
        // Store warning message and increment count
        strncpy(last_warning_message, message, sizeof(last_warning_message) - 1);
        last_warning_message[sizeof(last_warning_message) - 1] = '\0';
        warning_count++;
        
        // Print warning with formatting
        fprintf(stderr, "⚠️  WARNING [%d]: %s\n", warning_count, message);
        
        return warning_count;
        
    } else if (strcmp(func_name, "error") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.error() requires one argument (message)\n");
            return 0;
        }
        
        // Get error message from argument
        ASTNode* msg_node = &args_node->children[0];
        if (msg_node->type != AST_EXPR || !msg_node->text) {
            fprintf(stderr, "Error: debug.error() message must be a string\n");
            return 0;
        }
        
        // Extract message (remove quotes)
        char message[2048];
        if (is_string_literal(msg_node->text)) {
            size_t len = strlen(msg_node->text);
            if (len > 2) {
                strncpy(message, msg_node->text + 1, len - 2);
                message[len - 2] = '\0';
            } else {
                message[0] = '\0';
            }
        } else {
            strncpy(message, msg_node->text, sizeof(message) - 1);
            message[sizeof(message) - 1] = '\0';
        }
        
        // Validate message
        if (strlen(message) == 0) {
            fprintf(stderr, "Error: debug.error() message cannot be empty\n");
            return 0;
        }
        
        // Store error message and increment count
        strncpy(last_error_message, message, sizeof(last_error_message) - 1);
        last_error_message[sizeof(last_error_message) - 1] = '\0';
        error_count++;
        
        // Print error with formatting
        fprintf(stderr, "❌ ERROR [%d]: %s\n", error_count, message);
        
        return error_count;
        
    } else if (strcmp(func_name, "assert") == 0) {
        if (args_node->child_count < 2) {
            fprintf(stderr, "Error: debug.assert() requires two arguments (condition, message)\n");
            return 0;
        }
        
        // Get condition from first argument
        ASTNode* cond_node = &args_node->children[0];
        if (cond_node->type != AST_EXPR || !cond_node->text) {
            fprintf(stderr, "Error: debug.assert() condition must be a valid expression\n");
            return 0;
        }
        
        // Get message from second argument
        ASTNode* msg_node = &args_node->children[1];
        if (msg_node->type != AST_EXPR || !msg_node->text) {
            fprintf(stderr, "Error: debug.assert() message must be a string\n");
            return 0;
        }
        
        // Extract message (remove quotes)
        char message[2048];
        if (is_string_literal(msg_node->text)) {
            size_t len = strlen(msg_node->text);
            if (len > 2) {
                strncpy(message, msg_node->text + 1, len - 2);
                message[len - 2] = '\0';
            } else {
                message[0] = '\0';
            }
        } else {
            strncpy(message, msg_node->text, sizeof(message) - 1);
            message[sizeof(message) - 1] = '\0';
        }
        
        // For now, we'll use a simple assertion check
        // In a full implementation, this would evaluate the condition
        int assertion_passed = 1; // Placeholder
        
        if (assertion_passed) {
            printf("✅ ASSERTION PASSED: %s\n", message);
            return 1;
        } else {
            fprintf(stderr, "❌ ASSERTION FAILED: %s\n", message);
            error_count++;
            return 0;
        }
        
    } else if (strcmp(func_name, "start_timer") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: debug.start_timer() takes no arguments\n");
            return 0;
        }
        
        if (performance_timer_active) {
            fprintf(stderr, "Warning: Timer already active, restarting...\n");
        }
        
        // Start performance timer
        performance_start_time = clock();
        performance_timer_active = 1;
        
        printf("⏱️  Performance timer started\n");
        return 1;
        
    } else if (strcmp(func_name, "end_timer") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: debug.end_timer() takes no arguments\n");
            return 0;
        }
        
        if (!performance_timer_active) {
            fprintf(stderr, "Error: No timer active to stop\n");
            return 0;
        }
        
        // Stop performance timer and calculate elapsed time
        clock_t end_time = clock();
        double elapsed_time = ((double)(end_time - performance_start_time)) / CLOCKS_PER_SEC * 1000.0;
        
        performance_timer_active = 0;
        
        printf("⏱️  Performance timer stopped: %.2f ms\n", elapsed_time);
        return (long long)(elapsed_time * 1000); // Return in microseconds for precision
        
    } else if (strcmp(func_name, "get_stats") == 0) {
        if (args_node->child_count != 0) {
            fprintf(stderr, "Error: debug.get_stats() takes no arguments\n");
            return 0;
        }
        
        // Display debugging statistics
        printf("📊 DEBUG STATISTICS:\n");
        printf("====================\n");
        printf("  Warnings: %d\n", warning_count);
        printf("  Errors: %d\n", error_count);
        printf("  Debug Mode: %s\n", debug_mode ? "ON" : "OFF");
        printf("  Timer Active: %s\n", performance_timer_active ? "YES" : "NO");
        
        if (strlen(last_warning_message) > 0) {
            printf("  Last Warning: %s\n", last_warning_message);
        }
        
        if (strlen(last_error_message) > 0) {
            printf("  Last Error: %s\n", last_error_message);
        }
        
        return warning_count + error_count;
        
    } else if (strcmp(func_name, "set_debug_mode") == 0) {
        if (args_node->child_count < 1) {
            fprintf(stderr, "Error: debug.set_debug_mode() requires one argument (enabled)\n");
            return 0;
        }
        
        // Get debug mode setting from argument
        ASTNode* mode_node = &args_node->children[0];
        if (mode_node->type != AST_EXPR || !mode_node->text) {
            fprintf(stderr, "Error: debug.set_debug_mode() argument must be a valid expression\n");
            return 0;
        }
        
        // For now, we'll use a simple toggle
        // In a full implementation, this would evaluate the condition
        debug_mode = !debug_mode; // Toggle mode
        
        printf("🔧 Debug mode %s\n", debug_mode ? "enabled" : "disabled");
        return debug_mode ? 1 : 0;
        
    } else {
        fprintf(stderr, "Error: Unknown debug function '%s'\n", func_name);
        return 0;
    }
}